<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Distance-based Narrative Alignment Score (NAS-D)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        
        /* --- SMOOTHNESS & PERFORMANCE ENHANCEMENTS --- */
        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Inter', sans-serif;
            transition: background 1.5s cubic-bezier(0.25, 0.1, 0.25, 1);
        }

        :root {
            --ease-out-quad: cubic-bezier(0.25, 0.46, 0.45, 0.94);
            --ease-out-cubic: cubic-bezier(0.215, 0.610, 0.355, 1.000);
        }

        /* --- Glassmorphism & Enhanced Card Styles --- */
        .interactive-card {
            background: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: transform 0.35s var(--ease-out-cubic), 
                        box-shadow 0.35s var(--ease-out-cubic), 
                        border-color 0.35s var(--ease-out-cubic);
            will-change: transform, box-shadow;
        }
        .interactive-card:hover {
            box-shadow: 0 12px 30px -8px rgba(0, 0, 0, 0.12), 0 8px 15px -8px rgba(0, 0, 0, 0.1);
            transform: translateY(-5px);
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        .demo-card { background: linear-gradient(135deg, rgba(255, 255, 255, 0.6) 0%, rgba(248, 250, 252, 0.5) 100%); border-color: rgba(226, 232, 240, 0.7); }
        .intro-card { background: linear-gradient(135deg, rgba(254, 252, 232, 0.6) 0%, rgba(254, 243, 199, 0.5) 100%); border-color: rgba(251, 191, 36, 0.5); }
        .metrics-card { background: linear-gradient(135deg, rgba(240, 249, 255, 0.6) 0%, rgba(219, 234, 254, 0.5) 100%); border-color: rgba(147, 197, 253, 0.6); }
        .formula-card { background: linear-gradient(135deg, rgba(237, 233, 254, 0.6) 0%, rgba(221, 214, 254, 0.5) 100%); border-color: rgba(196, 181, 253, 0.6); }

        /* Ghost score style for predictions */
        .ghost-score {
            color: #9ca3af;
            font-weight: 700;
        }

        /* Tooltips */
        #chartTooltip {
            position: fixed; background: rgba(45, 55, 72, 0.9); backdrop-filter: blur(5px); color: white; padding: 8px 12px; border-radius: 6px;
            font-size: 0.8rem; z-index: 100; pointer-events: none; opacity: 0; 
            transition: opacity 0.25s var(--ease-out-quad), transform 0.25s var(--ease-out-quad);
            transform: scale(0.95);
        }
        #chartTooltip.visible {
            opacity: 1;
            transform: scale(1);
        }
        #chartTooltip.penalty { border-left: 4px solid #dc2626; }
        #chartTooltip.no-penalty { border-left: 4px solid #22c55e; }
        
        /* Segment List Styles */
        .segment-list ul li { 
            margin-bottom: 4px; line-height: 1.4; font-size: 0.8rem; color: #4b5563; padding: 4px 8px; border-radius: 0.375rem; 
            cursor: pointer; 
            transition: background-color 0.25s var(--ease-out-quad), border-color 0.25s var(--ease-out-quad), transform 0.25s var(--ease-out-quad), box-shadow 0.25s var(--ease-out-quad);
            border: 1px solid #e5e7eb; user-select: none; display: flex; justify-content: space-between; align-items: center; background: rgba(255,255,255,0.4); 
            will-change: background-color, transform;
        }
        .segment-list ul li:hover { background-color: #f0fdfa; border-color: #ccfbf1; transform: translateX(2px); }
        .segment-list ul li.highlight { background-color: #cffafe !important; border-color: #67e8f9 !important; transform: scale(1.03); box-shadow: 0 4px 12px rgba(103, 232, 249, 0.6); }
        .segment-list ul li.inactive-chunk { text-decoration: line-through; color: #9ca3af; background-color: #f3f4f6; }
        .segment-list ul li.inactive-chunk:hover { background-color: #e5e7eb; }
        .segment-list ul li.dragging { opacity: 0.5; background-color: #c7d2fe !important; cursor: grabbing; transform: scale(1.05); box-shadow: 0 8px 16px rgba(0,0,0,0.2); }
        @keyframes pulse { 0%, 100% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.02); opacity: 0.7; } }
        .drag-placeholder { height: 2.5em; background-color: #eef2ff; border: 2px dashed #a5b4fc; margin-bottom: 4px; border-radius: 0.375rem; display: flex; align-items: center; justify-content: center; font-size: 0.8rem; color: #64748b; animation: pulse 1.5s infinite; }

        /* Marker Styles */
        .gen-marker {
            position: absolute; width: 12px; height: 12px; border-radius: 50%;
            background-color: #8b5cf6; border: 2px solid white;
            cursor: grab; box-shadow: 0 2px 4px rgba(0,0,0,0.3); z-index: 10;
            transition: transform 0.25s var(--ease-out-cubic), background-color 0.25s var(--ease-out-cubic), box-shadow 0.25s var(--ease-out-cubic);
            will-change: transform;
        }
        .gen-marker:hover { transform: scale(1.4); }
        .gen-marker.dragging { background-color: #a78bfa; box-shadow: 0 4px 8px rgba(0,0,0,0.4); transform: scale(1.5); cursor: grabbing; }
        
        .marker-penalty-label {
            position: absolute; top: 14px; left: 50%; transform: translateX(-50%);
            font-size: 0.7rem; color: #dc2626; font-weight: 600;
            background-color: rgba(255, 255, 255, 0.9); padding: 1px 4px;
            border-radius: 3px; display: none; white-space: nowrap;
            border: 1px solid rgba(220, 38, 38, 0.3);
        }
        .gen-marker:hover .marker-penalty-label { display: block; }

        /* Tour Styles */
        #tour-overlay { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 9998; 
            opacity: 0; transition: opacity 0.4s ease-in-out; pointer-events: none; 
        }
        .tour-highlight { 
            position: relative; z-index: 9999; 
            box-shadow: 0 0 0 9999px rgba(0,0,0,0.6), 0 0 20px rgba(255, 255, 255, 0.9); 
            border-radius: 0.5rem; transition: box-shadow 0.4s ease-in-out; 
        }
        #tour-callout { 
            position: absolute; background: white; color: #334155; padding: 1rem; border-radius: 0.5rem; 
            box-shadow: 0 5px 15px rgba(0,0,0,0.2); z-index: 10000; max-width: 300px; 
            border-left: 4px solid #3b82f6; 
            transition: opacity 0.3s var(--ease-out-cubic), transform 0.3s var(--ease-out-cubic);
            transform: translateY(10px);
            opacity: 0;
        }
        #tour-callout.visible {
            transform: translateY(0);
            opacity: 1;
        }
        #tour-callout button { 
            background-color: #3b82f6; color: white; padding: 0.5rem 1rem; border: none; border-radius: 0.375rem; cursor: pointer; 
            transition: background-color 0.2s var(--ease-out-quad), transform 0.2s var(--ease-out-quad); 
        }
        #tour-callout button:hover { background-color: #2563eb; transform: translateY(-1px); }

        /* Other elements */
        .axis-label { position: absolute; font-size: 0.75rem; color: #475569; font-weight: 500; white-space: nowrap; z-index: 6; }
        .ideal-mapping-window { position: absolute; border: 2px solid #0d9488; background-color: rgba(20, 184, 166, 0.1); box-sizing: border-box; z-index: 1; transition: all 0.3s var(--ease-out-quad); pointer-events: none; border-radius: 0.25rem; }
        .lct-padding-window { position: absolute; background-color: rgba(253, 224, 71, 0.15); box-sizing: border-box; z-index: 0; transition: all 0.2s ease-out; pointer-events: none; border: 1px dashed #facc15; border-radius: 0.25rem; }
        .chart-grid-background { background-image: linear-gradient(to right, #e2e8f0 1px, transparent 1px), linear-gradient(to bottom, #e2e8f0 1px, transparent 1px); }
        .preset-btn { transition: all 0.2s var(--ease-out-quad); background: linear-gradient(135deg, #0d9488 0%, #14b8a6 100%); }
        .preset-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(13, 148, 136, 0.3); }
        .pattern-bg { background-image: radial-gradient(circle at 2px 2px, rgba(20, 184, 166, 0.1) 1px, transparent 0); background-size: 20px 20px; }
        .math-formula { background: linear-gradient(135deg, rgba(248, 250, 252, 0.7) 0%, rgba(241, 245, 249, 0.6) 100%); border: 1px solid #cbd5e1; font-family: 'Courier New', monospace; }
        .step-number { background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%); color: white; width: 2rem; height: 2rem; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 0.875rem; flex-shrink: 0; }
        details summary { cursor: pointer; user-select: none; transition: color 0.2s var(--ease-out-quad); }
        details summary:hover { color: #1d4ed8; }
        details summary::-webkit-details-marker { display: none; }
        details summary .summary-icon { display: inline-block; margin-right: 0.5rem; transition: transform 0.25s var(--ease-out-cubic); }
        details[open] summary .summary-icon { transform: rotate(90deg); }
    </style>
</head>
<body class="h-full text-slate-700 antialiased">
    <div id="app-background" class="fixed inset-0 z-[-1] transition-all duration-1000"></div>
    <div id="tour-overlay"></div>
    <div id="chartTooltip"></div>

    <main class="w-full max-w-8xl mx-auto p-4 sm:p-6 lg:p-8 min-h-screen">
        
        <!-- Header -->
        <div class="text-center mb-8 relative">
            <div class="flex items-center justify-center mb-4">
                <div class="bg-teal-100 text-teal-800 px-3 py-1 rounded-full text-xs font-semibold uppercase tracking-wide mr-2">Interactive Demo</div>
                <div class="bg-amber-100 text-amber-800 px-3 py-1 rounded-full text-xs font-semibold">Distance-based Penalties</div>
            </div>
            <h1 class="text-3xl sm:text-4xl font-bold bg-gradient-to-r from-teal-600 to-teal-800 bg-clip-text text-transparent">Distance-based Narrative Alignment Score (NAS-D)</h1>
            <p class="mt-3 text-lg text-slate-600 max-w-3xl mx-auto">Assess chronological misalignment by penalizing matches located outside their expected narrative positions within mapping windows.</p>
            <button id="start-tour-btn" class="absolute top-0 right-0 bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-full transition-transform transform hover:scale-105">
                <i class="fas fa-magic mr-2"></i>Start Tour
            </button>
        </div>

        <!-- Introduction Section -->
        <div class="mb-8">
            <div id="tour-step-1" class="intro-card interactive-card rounded-xl p-6">
                <div class="flex items-center mb-4"><i class="fas fa-lightbulb text-amber-600 text-xl mr-3"></i><h2 class="text-xl font-semibold text-amber-800">Introduction to Distance-based NAS</h2></div>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
                    <div class="bg-white bg-opacity-60 p-4 rounded-lg"><h3 class="font-semibold text-amber-700 mb-2 flex items-center"><i class="fas fa-question-circle text-amber-500 mr-2"></i>What is NAS-D?</h3><p class="text-sm text-slate-700">NAS-D measures chronological misalignment by calculating distance-based penalties when text segments are matched outside their expected narrative positions (mapping windows).</p></div>
                    <div class="bg-white bg-opacity-60 p-4 rounded-lg"><h3 class="font-semibold text-amber-700 mb-2 flex items-center"><i class="fas fa-exclamation-triangle text-amber-500 mr-2"></i>Why NAS-D?</h3><p class="text-sm text-slate-700">Traditional LAS measures semantic similarity but ignores chronological order. NAS-D explicitly evaluates narrative structure and sequence integrity, detecting temporal misalignments.</p></div>
                    <div class="bg-white bg-opacity-60 p-4 rounded-lg"><h3 class="font-semibold text-amber-700 mb-2 flex items-center"><i class="fas fa-cogs text-amber-500 mr-2"></i>How it Works</h3><p class="text-sm text-slate-700">NAS-D creates ideal mapping windows, calculates distance penalties for out-of-window matches, applies LCT tolerance, and normalizes against maximum possible penalty.</p></div>
                </div>
                <details id="tour-step-2" class="mb-4">
                    <summary class="font-semibold text-amber-700 mb-3 flex items-center"><i class="fas fa-chevron-right summary-icon"></i>Algorithm Details & Mathematics</summary>
                    <div class="mt-4 space-y-6 ml-6 border-l-2 border-slate-200 pl-6">
                        
                        <!-- Step 1 -->
                        <div class="flex items-start">
                            <div class="step-number mr-4">1</div>
                            <div>
                                <h4 class="font-semibold text-slate-800 mb-1">LCT Window Calculation</h4>
                                <p class="text-sm text-slate-600 mb-2">Calculate Local Chronology Threshold window height based on axis ratio to determine forgiveness zones.</p>
                                <div class="math-formula p-3 rounded-lg text-sm">
                                    <h5 class="font-semibold text-slate-700 mb-1">LCT Window Height:</h5>
                                    <code class="text-xs block">if y_axis ≤ x_axis: lct_window = ceil(y_axis/x_axis)</code>
                                    <code class="text-xs block">else: depends on ratio decimal part</code>
                                </div>
                            </div>
                        </div>

                        <!-- Step 2 -->
                        <div class="flex items-start">
                            <div class="step-number mr-4">2</div>
                            <div>
                                <h4 class="font-semibold text-slate-800 mb-1">Raw Distance Measurement</h4>
                                <p class="text-sm text-slate-600 mb-2">Calculate displacement from mapping window boundaries for out-of-window matches.</p>
                                <div class="math-formula p-3 rounded-lg text-sm">
                                    <h5 class="font-semibold text-slate-700 mb-1">Distance Penalty:</h5>
                                    <code class="text-xs block">if idx < start: dist = start - idx</code>
                                    <code class="text-xs block">elif idx ≥ end: dist = idx - (end-1)</code>
                                    <code class="text-xs block">penalty = dist / length</code>
                                </div>
                            </div>
                        </div>

                        <!-- Step 3 -->
                        <div class="flex items-start">
                            <div class="step-number mr-4">3</div>
                            <div>
                                <h4 class="font-semibold text-slate-800 mb-1">LCT Filtering & Normalization</h4>
                                <p class="text-sm text-slate-600 mb-2">Apply LCT threshold to ignore minor deviations within tolerance and normalize by sequence length.</p>
                                <div class="math-formula p-3 rounded-lg text-sm">
                                    <h5 class="font-semibold text-slate-700 mb-1">Final Score:</h5>
                                    <code class="text-xs block">threshold = lct × lct_window</code>
                                    <code class="text-xs block">if dist ≤ threshold: penalty = 0</code>
                                    <code class="text-xs block">NAS-D = 1 - (total_penalty / max_penalty)</code>
                                </div>
                            </div>
                        </div>
                    </div>
                </details>
            </div>
        </div>

        <!-- Main Content Area -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <div class="lg:col-span-2 space-y-8">
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                    <div id="tour-step-4" class="demo-card interactive-card rounded-xl p-4">
                        <div class="text-center mb-4"><div class="inline-flex items-center bg-teal-100 text-teal-800 px-3 py-1 rounded-full text-xs font-semibold mb-2"><i class="fas fa-crosshairs mr-1"></i>PRECISION NAS-D</div><h2 class="text-lg font-bold text-slate-800">Gen → Ref Alignment</h2></div>
                        <div class="relative w-full max-w-md mx-auto pt-4 pb-36 pl-20 pr-4">
                            <div class="absolute top-1/2 -left-8 -translate-y-16 -rotate-90 font-semibold text-sm text-slate-600 whitespace-nowrap">Reference Chunks</div>
                            <div class="absolute bottom-24 left-1/2 -translate-x-1/4 font-semibold text-sm text-slate-600">Generated Chunks</div>
                            <div class="relative w-full aspect-square">
                                <div id="precisionChartGrid" class="absolute inset-0 bg-white rounded-lg chart-grid-background border border-slate-200">
                                    <div id="precisionLctPaddingContainer"></div>
                                    <div id="precisionIdealMappingContainer"></div>
                                    <div id="precisionMarkerContainer"></div>
                                    <div id="precisionAxisLabelContainerY"></div>
                                    <div id="precisionAxisLabelContainerX"></div>
                                </div>
                            </div>
                            <div id="precisionChartMetrics" class="absolute -bottom-2 left-0 right-0 grid grid-cols-3 gap-x-4 gap-y-1 text-center text-xs text-slate-600 bg-white/80 p-2 rounded-md">
                                <div><span>Penalty:</span><br><span id="precisionActualPenalty" class="font-bold text-slate-800">0.00</span> <span id="precisionActualPenaltyPreview" class="ghost-score"></span></div>
                                <div><span>Max Penalty:</span><br><span id="precisionMaxPenalty" class="font-bold text-slate-800">0.00</span> <span id="precisionMaxPenaltyPreview" class="ghost-score"></span></div>
                                <div><span>Score:</span><br><span id="precisionDistNasScore" class="font-bold text-teal-600 text-sm">0.000</span> <span id="precisionDistNasScorePreview" class="ghost-score"></span></div>
                            </div>
                        </div>
                    </div>
                    <div class="demo-card interactive-card rounded-xl p-4">
                        <div class="text-center mb-4"><div class="inline-flex items-center bg-amber-100 text-amber-800 px-3 py-1 rounded-full text-xs font-semibold mb-2"><i class="fas fa-search mr-1"></i>RECALL NAS-D</div><h2 class="text-lg font-bold text-slate-800">Ref → Gen Alignment</h2></div>
                        <div class="relative w-full max-w-md mx-auto pt-4 pb-36 pl-20 pr-4">
                            <div class="absolute top-1/2 -left-8 -translate-y-16 -rotate-90 font-semibold text-sm text-slate-600 whitespace-nowrap">Generated Chunks</div>
                            <div class="absolute bottom-24 left-1/2 -translate-x-1/4 font-semibold text-sm text-slate-600">Reference Chunks</div>
                            <div class="relative w-full aspect-square">
                                <div id="recallChartGrid" class="absolute inset-0 bg-white rounded-lg chart-grid-background border border-slate-200">
                                    <div id="recallLctPaddingContainer"></div>
                                    <div id="recallIdealMappingContainer"></div>
                                    <div id="recallMarkerContainer"></div>
                                    <div id="recallAxisLabelContainerY"></div>
                                    <div id="recallAxisLabelContainerX"></div>
                                </div>
                            </div>
                             <div id="recallChartMetrics" class="absolute -bottom-2 left-0 right-0 grid grid-cols-3 gap-x-4 gap-y-1 text-center text-xs text-slate-600 bg-white/80 p-2 rounded-md">
                                <div><span>Penalty:</span><br><span id="recallActualPenalty" class="font-bold text-slate-800">0.00</span> <span id="recallActualPenaltyPreview" class="ghost-score"></span></div>
                                <div><span>Max Penalty:</span><br><span id="recallMaxPenalty" class="font-bold text-slate-800">0.00</span> <span id="recallMaxPenaltyPreview" class="ghost-score"></span></div>
                                <div><span>Score:</span><br><span id="recallDistNasScore" class="font-bold text-amber-600 text-sm">0.000</span> <span id="recallDistNasScorePreview" class="ghost-score"></span></div>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="tour-step-5" class="demo-card interactive-card rounded-xl p-6">
                    <div class="text-center mb-6"><h3 class="text-lg font-semibold text-slate-800 mb-2">Interactive Narrative Management</h3><p class="text-sm text-slate-500">Drag to reorder • Click to activate/deactivate • Hover items to see similarities on the grid</p></div>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div class="segment-list" id="referenceSegments"><div class="flex justify-between items-center mb-2"><h4 class="text-md font-semibold text-slate-700 flex items-center"><i class="fas fa-list text-teal-600 mr-2"></i>Reference (<span id="activeRefChunkCount">0</span>/<span id="totalRefChunkCount">0</span>)</h4><button id="resetRefOrderBtn" title="Reset Reference Order &amp; Reactivate All" class="text-slate-500 hover:text-blue-600 transition"><i class="fas fa-undo text-sm"></i></button></div><ul id="referenceSegmentsUl" class="space-y-1 h-72 overflow-y-auto pr-2 bg-slate-50/50 rounded p-2 border"></ul></div>
                        <div class="segment-list" id="generatedSegments"><div class="flex justify-between items-center mb-2"><h4 class="text-md font-semibold text-slate-700 flex items-center"><i class="fas fa-list text-amber-600 mr-2"></i>Generated (<span id="activeGenChunkCount">0</span>/<span id="totalGenChunkCount">0</span>)</h4><button id="resetGenOrderBtn" title="Reset Generated Order &amp; Reactivate All" class="text-slate-500 hover:text-blue-600 transition"><i class="fas fa-undo text-sm"></i></button></div><ul id="generatedSegmentsUl" class="space-y-1 h-72 overflow-y-auto pr-2 bg-slate-50/50 rounded p-2 border"></ul></div>
                    </div>
                    <!-- New Advanced Interactions Tip Section -->
                    <details class="mt-4">
                        <summary class="font-semibold text-sm text-slate-600 hover:text-blue-600">Explore Advanced Interactions <i class="fas fa-chevron-down summary-icon text-xs"></i></summary>
                        <div class="mt-2 space-y-3 text-xs text-slate-600 bg-slate-50/50 p-4 rounded-lg border">
                            <p>▶ <strong>Simulate missing content:</strong> Disable chunks from the <strong>Generated</strong> list to see how the score changes.</p>
                            <p>▶ <strong>Simulate extra content (hallucination):</strong> Disable chunks from the <strong>Reference</strong> list and observe the impact on the score.</p>
                            <p>▶ <strong>Progressively disable chunks</strong> one by one from the beginning, middle, end, or at random to see how the ideal band and actual path react.</p>
                            <p>▶ <strong>Observe the score jump:</strong> Notice that when you disable most of the content from either list, the score paradoxically jumps to 1.0. This is because the problem becomes too simple. See the <strong>Window Regularizer Demo</strong> to understand how this is fixed.</p>
                        </div>
                    </details>
                </div>
            </div>

            <!-- Controls Panel -->
            <div class="lg:col-span-1">
                <div class="sticky top-6 space-y-6">
                    <div id="tour-step-6" class="metrics-card interactive-card rounded-xl p-6">
                        <h3 class="text-lg font-semibold text-blue-800 mb-4 flex items-center"><i class="fas fa-tachometer-alt text-blue-600 mr-2"></i>Live NAS-D Metrics</h3>
                        <div class="space-y-4">
                            <div class="text-center bg-blue-50/70 p-3 rounded-lg border border-blue-200">
                                <label class="block text-sm font-medium text-blue-700 mb-1">Overall NAS-D (F1)</label>
                                <span id="f1DistNasValue" class="text-4xl font-bold text-blue-600">0.000</span>
                                <span id="f1DistNasValuePreview" class="text-4xl ghost-score"></span>
                                <p class="text-xs text-slate-500 mt-1">Harmonic mean of P & R</p>
                            </div>
                                <div class="grid grid-cols-2 gap-4">
                                    <div class="text-center">
                                        <label class="block text-sm font-medium text-blue-700 mb-1">Precision NAS-D</label>
                                        <span id="overallPrecisionNas" class="text-3xl font-bold text-teal-600">0.000</span>
                                        <span id="overallPrecisionNasPreview" class="text-3xl ghost-score"></span>
                                        <p class="text-xs text-slate-500 mt-1">Gen → Ref penalties</p>
                                    </div>
                                    <div class="text-center">
                                        <label class="block text-sm font-medium text-blue-700 mb-1">Recall NAS-D</label>
                                        <span id="overallRecallNas" class="text-3xl font-bold text-amber-600">0.000</span>
                                        <span id="overallRecallNasPreview" class="text-3xl ghost-score"></span>
                                        <p class="text-xs text-slate-500 mt-1">Ref → Gen penalties</p>
                                    </div>
                                </div>
                        </div>
                    </div>
                    <div id="tour-step-lct" class="formula-card interactive-card rounded-xl p-6">
                        <h3 class="text-lg font-semibold text-purple-800 mb-3 flex items-center"><i class="fas fa-sliders-h text-purple-600 mr-2"></i>LCT Parameter</h3>
                        <div class="flex items-center gap-4 mb-4"><label for="lctSlider" class="text-sm font-medium text-purple-700">Tolerance:</label><input type="range" id="lctSlider" min="0" max="5" value="0" step="1" class="flex-1 h-2 bg-purple-200 rounded-lg appearance-none cursor-pointer"><span id="lctValueDisplay" class="text-lg font-bold text-purple-600 w-8 text-center">0</span></div>
                        <div id="lctDescription" class="bg-purple-50/70 p-3 rounded-lg border border-purple-200 text-xs text-purple-700"></div>
                        <!-- New LCT Warning Section -->
                        <div class="mt-4 bg-amber-50/70 p-3 rounded-lg border border-amber-200 text-xs text-amber-800 flex items-start gap-2">
                           <i class="fas fa-exclamation-triangle mt-1 text-amber-600"></i>
                           <div>
                               <strong>Important:</strong> First, visit the <a href="#" class="font-bold underline hover:text-amber-900">LCT Effect Demo</a> to understand its impact. For this demo, keep LCT at 0. You can return later to experiment with this slider.
                           </div>
                       </div>
                    </div>
                    <div id="tour-step-3" class="demo-card interactive-card rounded-xl p-6">
                        <h3 class="text-lg font-semibold text-slate-800 mb-4 flex items-center"><i class="fas fa-magic text-purple-600 mr-2"></i>Chronological Scenarios</h3>
                        <div class="grid grid-cols-2 gap-3">
                            <button class="preset-btn w-full text-white px-3 py-2 rounded-lg text-xs font-medium" onclick="handleScenarioClick('optimal')"><i class="fas fa-sort-numeric-down mr-2"></i>Optimal</button>
                            <button class="preset-btn w-full text-white px-3 py-2 rounded-lg text-xs font-medium" onclick="handleScenarioClick('neighborSwap')"><i class="fas fa-exchange-alt mr-2"></i>Neighbor Swaps</button>
                            <button class="preset-btn w-full text-white px-3 py-2 rounded-lg text-xs font-medium" onclick="handleScenarioClick('reverse')"><i class="fas fa-sort-numeric-up mr-2"></i>Reverse</button>
                            <button class="preset-btn w-full text-white px-3 py-2 rounded-lg text-xs font-medium" onclick="handleScenarioClick('minorDisorders')"><i class="fas fa-random mr-2"></i>Minor Disorders</button>
                            <button class="preset-btn w-full text-white px-3 py-2 rounded-lg text-xs font-medium" onclick="handleScenarioClick('majorDisorder')"><i class="fas fa-exclamation-triangle mr-2"></i>Major Disorder</button>
                            <button class="preset-btn w-full text-white px-3 py-2 rounded-lg text-xs font-medium" onclick="handleScenarioClick('rotateHalf')"><i class="fas fa-sync-alt mr-2"></i>Rotate Half</button>
                        </div>
                        <div id="scenarioTip" class="mt-4 bg-slate-50/70 p-3 rounded-lg border border-slate-200 text-xs text-slate-600 transition-all duration-300">
                           <p><strong>Tip:</strong> Start with "Neighbor Swaps" to see how NAS-D detects subtle misalignments!</p>
                       </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <script>
        // --- DATA ---
        const masterReferenceChunks = ["The old market bell rings starting a busy market", "Vendors open their bright stalls in the busy square while the smell of fresh bread fills the air", "A young seller shouts out good deals as curious people gather around", "The steady ring of the bell sets the pace for the day", "A wise old vendor stops by his stall giving advice to those who pass by", "As the market gets busy the bell rings again at midday reminding everyone of the community spirit", "A light rain briefly slows the crowd but everyone is spirit stays strong", "Local storytellers tell simple tales that catch everyone is attention", "As evening comes the old bell rings one last time perfectly echoing the start of the day"];
        const masterGeneratedChunks = ["At first light the town s antique bell clangs signalling that the market is open for business", "Stalls spring to life all around the square their owners lifting colourful awnings while the warm scent of freshbaked bread drifts through the crowd", "A lively young hawker calls out bargains drawing curious shoppers closer", "That bell keeps time for everyone its steady peal guiding the morning rush", "Nearby an older merchant pauses at his booth offering bits of seasoned advice to anyone who will listen", "When noon rolls around the bell sounds again a friendly reminder of the shared spirit that holds the place together", "A brief shower scatters a few people but the mood never really fades", "Storytellers soon reclaim the moment with simple tales that pull listeners back in", "As dusk settles the same bell rings one final note neatly bookending the day it helped begin"];
        const masterSimilarityValues = [[0.737, 0.360, 0.286, 0.461, 0.284, 0.388, 0.062, 0.139, 0.396], [0.462, 0.783, 0.295, 0.269, 0.264, 0.227, 0.142, 0.158, 0.232], [0.244, 0.238, 0.814, 0.105, 0.337, 0.138, 0.120, 0.169, 0.084], [0.555, 0.259, 0.100, 0.734, 0.137, 0.593, 0.167, 0.199, 0.656], [0.258, 0.254, 0.293, 0.168, 0.774, 0.169, 0.110, 0.165, 0.151], [0.569, 0.340, 0.248, 0.483, 0.241, 0.764, 0.180, 0.216, 0.507], [0.134, 0.219, 0.106, 0.243, 0.133, 0.239, 0.689, 0.183, 0.177], [0.261, 0.259, 0.218, 0.266, 0.274, 0.286, 0.220, 0.679, 0.257], [0.537, 0.277, 0.059, 0.549, 0.218, 0.608, 0.192, 0.212, 0.869]];

        // --- STATE & DOM ---
        let activeReferenceIndices = [], activeGeneratedIndices = [];
        let markerPositions = { precision: [], recall: [] };
        let currentLct = 0;
        let animationFrameId = null;
        let isMarkerDragging = false;
        let draggedItemInfo = { element: null, originalIndex: null, type: null, placeholder: null };
        let draggedMarkerInfo = { chartType: null, id: null, element: null, chartGrid: null, startY: 0, startX: 0, mode: null, targetX: null };
        const lctSlider = document.getElementById('lctSlider');
        const lctValueDisplay = document.getElementById('lctValueDisplay');
        const lctDescription = document.getElementById('lctDescription');
        const referenceSegmentsUl = document.getElementById('referenceSegmentsUl');
        const generatedSegmentsUl = document.getElementById('generatedSegmentsUl');
        const chartTooltip = document.getElementById('chartTooltip');
        const appBackground = document.getElementById('app-background');
        const charts = {
            precision: { grid: document.getElementById('precisionChartGrid'), idealContainer: document.getElementById('precisionIdealMappingContainer'), lctContainer: document.getElementById('precisionLctPaddingContainer'), markerContainer: document.getElementById('precisionMarkerContainer'), axisX: document.getElementById('precisionAxisLabelContainerX'), axisY: document.getElementById('precisionAxisLabelContainerY'), actualPenalty: document.getElementById('precisionActualPenalty'), maxPenalty: document.getElementById('precisionMaxPenalty'), nasScore: document.getElementById('precisionDistNasScore'), actualPenaltyPreview: document.getElementById('precisionActualPenaltyPreview'), maxPenaltyPreview: document.getElementById('precisionMaxPenaltyPreview'), nasScorePreview: document.getElementById('precisionDistNasScorePreview') },
            recall: { grid: document.getElementById('recallChartGrid'), idealContainer: document.getElementById('recallIdealMappingContainer'), lctContainer: document.getElementById('recallLctPaddingContainer'), markerContainer: document.getElementById('recallMarkerContainer'), axisX: document.getElementById('recallAxisLabelContainerX'), axisY: document.getElementById('recallAxisLabelContainerY'), actualPenalty: document.getElementById('recallActualPenalty'), maxPenalty: document.getElementById('recallMaxPenalty'), nasScore: document.getElementById('recallDistNasScore'), actualPenaltyPreview: document.getElementById('recallActualPenaltyPreview'), maxPenaltyPreview: document.getElementById('recallMaxPenaltyPreview'), nasScorePreview: document.getElementById('recallDistNasScorePreview') }
        };
        const overallPreviews = {
            f1: document.getElementById('f1DistNasValuePreview'),
            precision: document.getElementById('overallPrecisionNasPreview'),
            recall: document.getElementById('overallRecallNasPreview')
        };
        
        // --- HELPER FUNCTIONS ---
        const easeOutCubic = t => 1 - Math.pow(1 - t, 3);
        
        // --- TOUR MANAGER ---
        const tourManager = {
            isActive: false,
            currentStep: 0,
            overlay: document.getElementById('tour-overlay'),
            steps: [
                { selector: '#tour-step-1', text: 'Welcome! This card provides a high-level overview of the NAS-D metric and its purpose.', position: 'bottom' },
                { selector: '#tour-step-2', text: 'Click here to see the step-by-step algorithm and mathematical formulas used for distance penalty calculations.', position: 'bottom'},
                { selector: '#tour-step-3', text: 'You can load pre-defined scenarios here. Let\'s try "Neighbor Swaps" to see how distance penalties work.', position: 'left', action: () => handleScenarioClick('neighborSwap') },
                { selector: '#tour-step-4', text: 'These charts show mapping windows (green), tolerance zones (yellow dashed), and draggable markers. You can drag the purple markers vertically to change alignments or horizontally to swap positions. Notice the live score preview as you drag!', position: 'top' },
                { selector: '#tour-step-5', text: 'You can directly manipulate the narrative by dragging or disabling segments. Try dragging purple markers vertically or horizontally to see penalty changes.', position: 'top' },
                { selector: '#tour-step-lct', text: 'This slider adjusts the "Local Chronological Tolerance" (LCT), which creates forgiveness zones (yellow dashed areas) for minor misalignments.', position: 'left' },
                { selector: '#tour-step-6', text: 'The final scores are calculated here. Notice how penalties decrease the NAS-D scores. Lower penalties = higher scores. Enjoy exploring!', position: 'left' }
            ],

            start: function() {
                this.isActive = true;
                this.currentStep = 0;
                this.overlay.style.pointerEvents = 'auto';
                this.overlay.style.opacity = '1';
                this.showStep();
            },

            next: function() {
                this.cleanupCurrentStep();
                this.currentStep++;
                if (this.currentStep < this.steps.length) {
                    if (this.steps[this.currentStep-1].action) {
                       this.steps[this.currentStep-1].action();
                    }
                    setTimeout(() => this.showStep(), 400);
                } else {
                    this.end();
                }
            },
            
            showStep: function() {
                const step = this.steps[this.currentStep];
                const targetElement = document.querySelector(step.selector);
                if (!targetElement) { this.end(); return; }

                targetElement.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });

                setTimeout(() => {
                    targetElement.classList.add('tour-highlight');
                    
                    const callout = document.createElement('div');
                    callout.id = 'tour-callout';
                    callout.innerHTML = `<p class="text-sm mb-4">${step.text}</p><div class="flex justify-end"><button onclick="tourManager.next()">Next &rarr;</button></div>`;
                    document.body.appendChild(callout);
                    
                    const targetRect = targetElement.getBoundingClientRect();
                    const calloutRect = callout.getBoundingClientRect();
                    const margin = 15;

                    const scrollY = window.scrollY || document.documentElement.scrollTop;
                    const scrollX = window.scrollX || document.documentElement.scrollLeft;

                    let top, left;

                    switch (step.position) {
                        case 'bottom':
                            top = targetRect.bottom + scrollY + margin;
                            left = targetRect.left + scrollX + (targetRect.width / 2) - (calloutRect.width / 2);
                            break;
                        case 'top':
                            top = targetRect.top + scrollY - calloutRect.height - margin;
                            left = targetRect.left + scrollX + (targetRect.width / 2) - (calloutRect.width / 2);
                            break;
                        case 'left':
                            top = targetRect.top + scrollY + (targetRect.height / 2) - (calloutRect.height / 2);
                            left = targetRect.left + scrollX - calloutRect.width - margin;
                            break;
                        case 'right':
                            top = targetRect.top + scrollY + (targetRect.height / 2) - (calloutRect.height / 2);
                            left = targetRect.right + scrollX + margin;
                            break;
                        default:
                            top = targetRect.bottom + scrollY + margin;
                            left = targetRect.left + scrollX;
                    }
                    
                    const viewportRight = scrollX + window.innerWidth;
                    const viewportBottom = scrollY + window.innerHeight;

                    if (left < scrollX + margin) left = scrollX + margin;
                    if (left + calloutRect.width > viewportRight - margin) left = viewportRight - calloutRect.width - margin;
                    if (top < scrollY + margin) top = scrollY + margin;
                    if (top + calloutRect.height > viewportBottom - margin) top = viewportBottom - calloutRect.height - margin;
                    
                    callout.style.top = `${top}px`;
                    callout.style.left = `${left}px`;

                    requestAnimationFrame(() => {
                        callout.classList.add('visible');
                    });
                }, 350);
            },
            
            cleanupCurrentStep: function() {
                const oldHighlight = document.querySelector('.tour-highlight');
                if (oldHighlight) oldHighlight.classList.remove('tour-highlight');
                const oldCallout = document.getElementById('tour-callout');
                if (oldCallout) oldCallout.remove();
            },

            end: function() {
                this.cleanupCurrentStep();
                this.isActive = false;
                this.overlay.style.opacity = '0';
                setTimeout(() => this.overlay.style.pointerEvents = 'none', 400);
            }
        };

        // --- DYNAMIC BACKGROUND ---
        function updateDynamicBackground(f1Score) {
            const score = isNaN(f1Score) ? 0 : f1Score;
            const hue = 120 * score;
            const saturation = 30 + 40 * score;
            const lightness = 85 + 10 * score;
            const startColor = `hsl(170, ${saturation-10}%, ${lightness-5}%)`;
            const endColor = `hsl(190, ${saturation}%, ${lightness}%)`;
            appBackground.style.background = `linear-gradient(135deg, ${startColor} 0%, ${endColor} 100%)`;
        }
        
        // --- CORE LOGIC ---
        function _calculate_f1(p, r) { return (p + r === 0) ? 0.0 : (2 * p * r) / (p + r); }
        
        function buildCurrentSimilarityMatrix(isForRecall) {
            const numRef = activeReferenceIndices.length;
            const numGen = activeGeneratedIndices.length;
            if (numRef === 0 || numGen === 0) return [];
            if (isForRecall) {
                 return activeGeneratedIndices.map(gIdx => activeReferenceIndices.map(rIdx => masterSimilarityValues[rIdx][gIdx]));
            } else {
                 return activeReferenceIndices.map(rIdx => activeGeneratedIndices.map(gIdx => masterSimilarityValues[rIdx][gIdx]));
            }
        }
        
        function get_mapping_windows_generic(lenX, lenY) {
            if (lenX === 0 || lenY === 0) return [];
            const isYLonger = lenY >= lenX;
            const longerLen = isYLonger ? lenY : lenX;
            const shorterLen = isYLonger ? lenX : lenY;
            const slope = longerLen / shorterLen;
            const mappingWindowSize = Math.ceil(slope);
            let direct_windows = [];
            for (let i = 0; i < shorterLen; i++) {
                const idx_point = i * slope;
                const start = Math.floor(idx_point);
                const end = Math.min(start + mappingWindowSize, longerLen);
                direct_windows.push({ start, end });
            }
            if (isYLonger) return direct_windows;
            let windows_for_X_items = Array(lenX).fill(null);
            for (let x_idx = 0; x_idx < lenX; x_idx++) {
                let mappedYIndices = [];
                direct_windows.forEach((y_window_on_x_axis, y_idx) => {
                    if (x_idx >= y_window_on_x_axis.start && x_idx < y_window_on_x_axis.end) { mappedYIndices.push(y_idx); }
                });
                if (mappedYIndices.length > 0) {
                    windows_for_X_items[x_idx] = { start: Math.min(...mappedYIndices), end: Math.max(...mappedYIndices) + 1 };
                } else { 
                    const proportionalYPos = Math.max(0, Math.min(lenY - 1, Math.floor((x_idx / lenX) * lenY)));
                    windows_for_X_items[x_idx] = { start: proportionalYPos, end: Math.min(proportionalYPos + 1, lenY) };
                }
            }
            return windows_for_X_items.map(w => w ? ({start: w.start, end: Math.max(w.start + 1, w.end)}) : null);
        }

        function findBestMatchIndex(similarityColumn) {
            if (!similarityColumn || similarityColumn.length === 0) return -1;
            let maxVal = -Infinity, maxIdx = -1;
            similarityColumn.forEach((val, idx) => { if (val > maxVal) { maxVal = val; maxIdx = idx; } });
            return maxIdx;
        }

        function calculateLctWindow(yAxis, xAxis) {
            if (xAxis === 0) return 0;
            const mappingWindowHeight = Math.ceil(yAxis / xAxis);
            const ratio = yAxis / xAxis;
            const ratioDecimalPart = ratio - Math.floor(ratio);
            
            if (yAxis <= xAxis) {
                return mappingWindowHeight;
            } else {
                if (0 < ratioDecimalPart && ratioDecimalPart <= 0.5) {
                    return mappingWindowHeight - 1;
                } else {
                    return mappingWindowHeight;
                }
            }
        }

        // Refactored to accept marker data as an argument for preview functionality
        function calculatePenaltiesAndNAS(chartType, markers) {
            const isRecall = chartType === 'recall';
            const numX = isRecall ? activeReferenceIndices.length : activeGeneratedIndices.length;
            const numY = isRecall ? activeGeneratedIndices.length : activeReferenceIndices.length;
            const idealWindows = get_mapping_windows_generic(numX, numY);

            if (numX === 0 || numY === 0 || !markers || markers.length === 0) return { actualPenalty: 0, maxPenalty: 0, nas: 1.0, markerPenalties: [] };

            const lctWindowHeight = calculateLctWindow(numY, numX);
            let totalActualPenalty = 0;
            const markerPenalties = [];
            for (let i = 0; i < numX; i++) {
                const marker = markers[i]; 
                const window = idealWindows[i];
                if (!marker || !window) continue;
                
                const markerY = marker.currentY; 
                const windowStart = window.start; 
                const windowEnd = window.end - 1; 
                const inWindow = (markerY >= windowStart && markerY <= windowEnd);
                
                let rawDistance = 0;
                if (!inWindow) {
                    if (markerY < windowStart) {
                        rawDistance = windowStart - markerY;
                    } else if (markerY > windowEnd) {
                        rawDistance = markerY - windowEnd;
                    }
                }
                
                const lctThreshold = currentLct * lctWindowHeight;
                const effectiveDistance = rawDistance <= lctThreshold ? 0 : rawDistance;
                const normalizedPenalty = numY > 0 ? effectiveDistance / numY : 0;
                
                totalActualPenalty += normalizedPenalty;
                markerPenalties.push({ id: marker.id, penalty: normalizedPenalty, rawDistance: rawDistance });
            }

            let maxTotalPenalty = 0;
            for (let i = 0; i < idealWindows.length; i++) {
                const window = idealWindows[i];
                const distDown = window.start;
                const distUp = numY - window.end;
                const maxDistanceForWindow = Math.max(distDown, distUp);
                maxTotalPenalty += maxDistanceForWindow;
            }
            
            const normalizedMaxPenalty = numY > 0 ? maxTotalPenalty / numY : 0;
            const nas = (normalizedMaxPenalty > 0) ? Math.max(0, 1 - (totalActualPenalty / normalizedMaxPenalty)) : 1.0;
            return { actualPenalty: totalActualPenalty, maxPenalty: normalizedMaxPenalty, nas: nas, markerPenalties: markerPenalties };
        }

        // --- RENDER LOGIC ---
        function renderChart(chartType, isAnimating = false) {
            const chartUI = charts[chartType];
            const isRecall = chartType === 'recall';
            const numX = isRecall ? activeReferenceIndices.length : activeGeneratedIndices.length;
            const numY = isRecall ? activeGeneratedIndices.length : activeReferenceIndices.length;
            const markers = markerPositions[chartType];
            
            if (!isAnimating) {
                chartUI.idealContainer.innerHTML = ''; chartUI.lctContainer.innerHTML = '';
                chartUI.axisX.innerHTML = ''; chartUI.axisY.innerHTML = '';
                chartUI.grid.style.backgroundSize = (numX > 0 && numY > 0) ? `calc(100% / ${numX}) calc(100% / ${numY})` : 'none';
                const xIndices = isRecall ? activeReferenceIndices : activeGeneratedIndices;
                const yIndices = isRecall ? activeGeneratedIndices : activeReferenceIndices;
                const yStep = Math.max(1, Math.ceil(numY / 6)); for (let i = 0; i < numY; i+=yStep) { const lbl=document.createElement('div'); lbl.className='axis-label'; lbl.textContent=yIndices[i]; lbl.style.left='-1rem'; lbl.style.top=`calc(100% - (${i}*100%/${numY}) - (50%/${numY}))`; lbl.style.transform='translateY(-50%) translateX(-100%)'; chartUI.axisY.appendChild(lbl); }
                const xStep = Math.max(1, Math.ceil(numX / 6)); for (let i = 0; i < numX; i+=xStep) { const lbl=document.createElement('div'); lbl.className='axis-label'; lbl.textContent=xIndices[i]; lbl.style.bottom='-1.5rem'; lbl.style.left=`calc(${i}*100%/${numX} + 50%/${numX})`; lbl.style.transform='translateX(-50%)'; chartUI.axisX.appendChild(lbl); }
                
                if (numX > 0 && numY > 0) {
                    const idealWindows = get_mapping_windows_generic(numX, numY);
                    const lctWindowHeight = calculateLctWindow(numY, numX);
                    const scaledLct = currentLct * lctWindowHeight;

                    idealWindows.forEach((window, x_idx) => {
                        const startY = window.start; const endY = window.end; const height = endY - startY;
                        const idealDiv = document.createElement('div');
                        idealDiv.className = 'ideal-mapping-window';
                        idealDiv.style.left = `calc(${x_idx} * 100% / ${numX})`; idealDiv.style.width = `calc(100% / ${numX})`;
                        idealDiv.style.bottom = `calc(${startY} * 100% / ${numY})`; idealDiv.style.height = `calc(${height} * 100% / ${numY})`;
                        chartUI.idealContainer.appendChild(idealDiv);
                        
                        const lctStartY = Math.max(0, startY - scaledLct); const lctEndY = Math.min(numY, endY + scaledLct);
                        const lctHeight = lctEndY - lctStartY;
                        const lctDiv = document.createElement('div');
                        lctDiv.className = 'lct-padding-window';
                        lctDiv.style.left = idealDiv.style.left; lctDiv.style.width = idealDiv.style.width;
                        lctDiv.style.bottom = `calc(${lctStartY} * 100% / ${numY})`; lctDiv.style.height = `calc(${lctHeight} * 100% / ${numY})`;
                        chartUI.lctContainer.appendChild(lctDiv);
                    });
                }
            }
            
            chartUI.markerContainer.innerHTML = '';
            if (numX > 0 && numY > 0 && markers.length > 0) {
                const { markerPenalties } = calculatePenaltiesAndNAS(chartType, markers);
                const penaltyMap = new Map(markerPenalties.map(p => [p.id, { penalty: p.penalty, rawDistance: p.rawDistance }]));
                markers.forEach(marker => {
                    const markerDiv = document.createElement('div');
                    markerDiv.className = 'gen-marker'; markerDiv.dataset.id = marker.id; markerDiv.dataset.chartType = chartType;
                    const penaltyInfo = penaltyMap.get(marker.id) || { penalty: 0, rawDistance: 0 };
                    
                    const penaltyLabel = document.createElement('span');
                    penaltyLabel.className = 'marker-penalty-label';
                    if (penaltyInfo.penalty > 0) { 
                        penaltyLabel.textContent = `-${penaltyInfo.rawDistance.toFixed(0)}`; 
                        penaltyLabel.style.display = 'block'; 
                    }
                    markerDiv.appendChild(penaltyLabel);
                    markerDiv.style.left = `calc(${(marker.id + 0.5)} * 100% / ${numX} - 6px)`;
                    markerDiv.style.bottom = `calc(${(marker.currentY + 0.5)} * 100% / ${numY} - 6px)`;
                    chartUI.markerContainer.appendChild(markerDiv);
                });
            }
        }
        
        function updateAndRenderAll() {
            if (animationFrameId) return;

            currentLct = parseInt(lctSlider.value); lctValueDisplay.textContent = currentLct; updateLctDescription();
            const nRef = activeReferenceIndices.length, nGen = activeGeneratedIndices.length;
            
            const precResults = calculatePenaltiesAndNAS('precision', markerPositions.precision);
            const recResults = calculatePenaltiesAndNAS('recall', markerPositions.recall);
            const f1 = _calculate_f1(precResults.nas, recResults.nas);
            
            renderSegmentLists();
            
            requestAnimationFrame(() => {
                renderChart('precision');
                renderChart('recall');
            });
            
            ['precision', 'recall'].forEach(type => {
                const chart = charts[type];
                const results = type === 'precision' ? precResults : recResults;
                animateNumber(chart.actualPenalty, parseFloat(chart.actualPenalty.textContent)||0, results.actualPenalty, 500);
                animateNumber(chart.maxPenalty, parseFloat(chart.maxPenalty.textContent)||0, results.maxPenalty, 500);
                animateNumber(chart.nasScore, parseFloat(chart.nasScore.textContent)||0, results.nas, 500);
            });
            
            animateNumber(document.getElementById('overallPrecisionNas'), parseFloat(document.getElementById('overallPrecisionNas').textContent)||0, precResults.nas, 500);
            animateNumber(document.getElementById('overallRecallNas'), parseFloat(document.getElementById('overallRecallNas').textContent)||0, recResults.nas, 500);
            animateNumber(document.getElementById('f1DistNasValue'), parseFloat(document.getElementById('f1DistNasValue').textContent)||0, f1, 500);
            
            updateDynamicBackground(f1);
        }
        
        // --- PREDICTION (GHOST) FUNCTIONS ---
        function showScorePreview(tempMarkerPositions) {
            const precResults = calculatePenaltiesAndNAS('precision', tempMarkerPositions.precision);
            const recResults = calculatePenaltiesAndNAS('recall', tempMarkerPositions.recall);
            const f1 = _calculate_f1(precResults.nas, recResults.nas);

            charts.precision.actualPenaltyPreview.textContent = `→ ${precResults.actualPenalty.toFixed(2)}`;
            charts.precision.maxPenaltyPreview.textContent = `→ ${precResults.maxPenalty.toFixed(2)}`;
            charts.precision.nasScorePreview.textContent = `→ ${precResults.nas.toFixed(3)}`;
            
            charts.recall.actualPenaltyPreview.textContent = `→ ${recResults.actualPenalty.toFixed(2)}`;
            charts.recall.maxPenaltyPreview.textContent = `→ ${recResults.maxPenalty.toFixed(2)}`;
            charts.recall.nasScorePreview.textContent = `→ ${recResults.nas.toFixed(3)}`;

            overallPreviews.f1.textContent = `→ ${f1.toFixed(3)}`;
            overallPreviews.precision.textContent = `→ ${precResults.nas.toFixed(3)}`;
            overallPreviews.recall.textContent = `→ ${recResults.nas.toFixed(3)}`;
        }

        function hideScorePreview() {
            for (const key in charts) {
                charts[key].actualPenaltyPreview.textContent = '';
                charts[key].maxPenaltyPreview.textContent = '';
                charts[key].nasScorePreview.textContent = '';
            }
             for (const key in overallPreviews) {
                overallPreviews[key].textContent = '';
            }
        }


        // --- EVENT BINDING & INITIALIZATION ---
        window.addEventListener('load', () => {
            activeReferenceIndices = Array.from({ length: masterReferenceChunks.length }, (_, i) => i);
            activeGeneratedIndices = Array.from({ length: masterGeneratedChunks.length }, (_, i) => i);
            
            document.getElementById('start-tour-btn').addEventListener('click', () => tourManager.start());
            
            document.getElementById('resetGenOrderBtn').addEventListener('click', () => resetSegmentOrder('generated'));
            document.getElementById('resetRefOrderBtn').addEventListener('click', () => resetSegmentOrder('reference'));
            lctSlider.addEventListener('input', updateAndRenderAll);
            [generatedSegmentsUl, referenceSegmentsUl].forEach(ul => {  
                ul.addEventListener('dragstart', handleSegmentDragStart);  
                ul.addEventListener('dragover', handleSegmentDragOver);
                ul.addEventListener('drop', handleSegmentDrop);
                ul.addEventListener('dragend', handleSegmentDragEnd);
            });
            
            document.addEventListener('mousedown', handlePointMarkerMouseDown);
            document.addEventListener('mousemove', handlePointMarkerMouseMove);
            document.addEventListener('mouseup', handlePointMarkerMouseUp);

            ['precisionMarkerContainer', 'recallMarkerContainer'].forEach(id => {
                document.getElementById(id).addEventListener('mouseover', e => {
                    if (e.target.classList.contains('gen-marker')) {
                        updateChartTooltip(e, e.target.dataset.chartType, parseInt(e.target.dataset.id));
                    }
                });
                document.getElementById(id).addEventListener('mouseout', e => {
                    if (e.target.classList.contains('gen-marker') && !isMarkerDragging) {
                        hideChartTooltip();
                    }
                });
            });

            let resizeTimer;
            window.addEventListener('resize', () => { clearTimeout(resizeTimer); resizeTimer = setTimeout(updateAndRenderAll, 150); });
            
            initializeAppState();
            updateAndRenderAll();
        });
        
        // --- Scenario Tips & Click Handler (Matching Line NAS) ---
        const scenarioTips = {
            optimal: '<strong>Tip:</strong> The path is perfectly aligned with zero penalties. Try dragging markers vertically or horizontally to see how penalties change.',
            neighborSwap: '<strong>Tip:</strong> Global order is maintained, but local misalignments create distance penalties. Notice the score drop from these small swaps.',
            reverse: '<strong>Tip:</strong> The alignment is completely reversed. Test how penalties change with and without LCT enabled.',
            minorDisorders: '<strong>Tip:</strong> Even a few out-of-place alignments can significantly impact the distance penalty score.',
            majorDisorder: '<strong>Tip:</strong> With major chaos, most markers are outside their windows, resulting in maximum distance penalties.',
            rotateHalf: '<strong>Tip:</strong> Local chronology is mostly preserved, but global order is wrong. Distance penalties are moderate due to shifted alignments.'
        };

        function handleScenarioClick(scenarioType) { 
            document.getElementById('scenarioTip').innerHTML = scenarioTips[scenarioType];
            let targetGenOrder = [...activeGeneratedIndices].sort((a,b) => a-b); 
            const n = targetGenOrder.length; 
            switch(scenarioType) { 
                case 'optimal': break; 
                case 'neighborSwap': for(let i=0; i < n - 1; i+=2) { [targetGenOrder[i], targetGenOrder[i+1]] = [targetGenOrder[i+1], targetGenOrder[i]]; } break; 
                case 'reverse': targetGenOrder.reverse(); break; 
                case 'minorDisorders': targetGenOrder.forEach((_, i) => { if (Math.random() > 0.6) { const swapWith = (i + (Math.random() > 0.5 ? 1 : -1) + n) % n; [targetGenOrder[i], targetGenOrder[swapWith]] = [targetGenOrder[swapWith], targetGenOrder[i]]; } }); break; 
                case 'majorDisorder': const reorderPattern = [2, 5, 1, 7, 0, 4, 8, 3, 6]; targetGenOrder = reorderPattern.slice(0, n); break; 
                case 'rotateHalf': const mid = Math.floor(n/2); targetGenOrder = [...targetGenOrder.slice(mid), ...targetGenOrder.slice(0, mid)]; break; 
            } 
            animatePathTransition(targetGenOrder); 
        }
        
        function animatePathTransition(targetGenOrder) { 
            if (animationFrameId) cancelAnimationFrame(animationFrameId); 
            const duration = 600;
            
            const startPositions = { 
                precision: JSON.parse(JSON.stringify(markerPositions.precision)),
                recall: JSON.parse(JSON.stringify(markerPositions.recall))
            };
            const genIndexToNewPosMap = new Map(targetGenOrder.map((originalIndex, newPos) => [originalIndex, newPos]));
            
            const targetPositions = { precision: [], recall: [] };
            startPositions.precision.forEach(startPoint => {
                const originalGenIndex = activeGeneratedIndices[startPoint.id];
                const newX = genIndexToNewPosMap.get(originalGenIndex);
                if (newX !== undefined) {
                    targetPositions.precision[newX] = { id: newX, currentY: startPoint.currentY };
                }
            });
            startPositions.recall.forEach(startPoint => {
                const newYforGen = genIndexToNewPosMap.get(activeGeneratedIndices[startPoint.currentY]);
                if (newYforGen !== undefined) {
                    targetPositions.recall[startPoint.id] = { id: startPoint.id, currentY: newYforGen };
                }
            });

            const startTime = performance.now();
            
            function tick(currentTime) {
                const elapsedTime = currentTime - startTime;
                const rawProgress = Math.min(elapsedTime / duration, 1);
                const progress = easeOutCubic(rawProgress);

                ['precision', 'recall'].forEach(chartType => {
                    for(let i=0; i < startPositions[chartType].length; i++) {
                        const start = startPositions[chartType][i];
                        const target = targetPositions[chartType][i];
                        if (start && target) {
                           markerPositions[chartType][i].currentY = start.currentY + (target.currentY - start.currentY) * progress;
                        }
                    }
                });
                
                requestAnimationFrame(() => {
                    renderChart('precision', true);
                    renderChart('recall', true);
                });

                if (rawProgress < 1) {
                    animationFrameId = requestAnimationFrame(tick);
                } else {
                    animationFrameId = null;
                    activeGeneratedIndices = targetGenOrder;
                    initializeAppState();
                    updateAndRenderAll();
                }
            }
            animationFrameId = requestAnimationFrame(tick);
        }
        
        function updateLctDescription() { lctDescription.innerHTML = ["<strong>Strict:</strong> Only exact window matches have zero penalty.", "<strong>Minor Tolerance:</strong> Small deviations outside windows are forgiven.", "<strong>Moderate Tolerance:</strong> Moderate distance deviations are ignored.", "<strong>High Tolerance:</strong> Significant misalignments receive forgiveness.", "<strong>Very High:</strong> Large distance penalties are substantially reduced.", "<strong>Maximum:</strong> Most distance penalties are eliminated."][parseInt(lctSlider.value)]; }
        function updateChartTooltip(e, type, id) {
            const highlightedItems = document.querySelectorAll('.segment-list li.highlight');
            highlightedItems.forEach(item => item.classList.remove('highlight'));
            
            chartTooltip.classList.add('visible');
            chartTooltip.style.left = `${e.clientX + 15}px`;
            chartTooltip.style.top = `${e.clientY + 15}px`;
            
            const marker = markerPositions[type].find(m => m.id === id);
            if (!marker) return;
            
            const isRecall = type === 'recall';
            
            const refOriginalIndex = isRecall ? activeReferenceIndices[id] : activeReferenceIndices[marker.currentY];
            const genOriginalIndex = isRecall ? activeGeneratedIndices[marker.currentY] : activeGeneratedIndices[id];

            const refLi = document.querySelector(`#referenceSegmentsUl li[data-original-index='${refOriginalIndex}']`);
            const genLi = document.querySelector(`#generatedSegmentsUl li[data-original-index='${genOriginalIndex}']`);
            if (refLi) refLi.classList.add('highlight');
            if (genLi) genLi.classList.add('highlight');

            const xOriginalIndex = (isRecall ? activeReferenceIndices : activeGeneratedIndices)[id];
            const yOriginalIndex = (isRecall ? activeGeneratedIndices : activeReferenceIndices)[marker.currentY];
            const mappingText = `${isRecall ? 'Ref' : 'Gen'} Chunk ${xOriginalIndex} ↔ ${isRecall ? 'Gen' : 'Ref'} Chunk ${yOriginalIndex}`;
            
            const { markerPenalties } = calculatePenaltiesAndNAS(type, markerPositions[type]);
            const penaltyInfo = markerPenalties.find(p => p.id === id);
            let penaltyText = '';
            let statusClass = '';
            if (penaltyInfo && penaltyInfo.penalty > 0) {
                statusClass = 'penalty';
                penaltyText = `<hr class="my-1 border-slate-500"><strong class="text-red-400">Distance Penalty</strong><br>Raw Distance: ${penaltyInfo.rawDistance}<br>Normalized: ${penaltyInfo.penalty.toFixed(3)}`;
            } else {
                statusClass = 'no-penalty';
                penaltyText = `<hr class="my-1 border-slate-500"><strong class="text-green-400">No Penalty</strong><br>Marker in valid window`;
            }
            chartTooltip.className = `visible ${statusClass}`;
            chartTooltip.innerHTML = mappingText + penaltyText;
        }
        function hideChartTooltip() {
            chartTooltip.classList.remove('visible');
            const highlightedItems = document.querySelectorAll('.segment-list li.highlight');
            highlightedItems.forEach(item => item.classList.remove('highlight'));
        }
        
        // Marker drag functions (WITH HORIZONTAL MOVEMENT LIKE LINE NAS)
        function handlePointMarkerMouseDown(e) { 
            if (!e.target.classList.contains('gen-marker')) return;
            e.preventDefault();
            isMarkerDragging = true;
            hideScorePreview(); // Clear any stale previews
            const marker = e.target;
            draggedMarkerInfo = { chartType: marker.dataset.chartType, id: parseInt(marker.dataset.id), element: marker, chartGrid: charts[marker.dataset.chartType].grid, startY: e.clientY, startX: e.clientX, mode: null, targetX: null };
            marker.classList.add('dragging');
            document.body.style.userSelect = 'none';
        }
        
        function handlePointMarkerMouseMove(e) {
            if (!isMarkerDragging || !draggedMarkerInfo.chartGrid) return;
            
            // This logic is now wrapped in requestAnimationFrame to prevent layout thrashing
            requestAnimationFrame(() => {
                if (!isMarkerDragging) return;
                const { chartType, id, chartGrid, startX, startY } = draggedMarkerInfo;
                if (!draggedMarkerInfo.mode) {
                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;
                    if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {
                        draggedMarkerInfo.mode = Math.abs(dx) > Math.abs(dy) ? 'horizontal' : 'vertical';
                        document.body.style.cursor = draggedMarkerInfo.mode === 'horizontal' ? 'ew-resize' : 'ns-resize';
                    }
                }
                
                // Create a temporary state for prediction
                const tempMarkers = JSON.parse(JSON.stringify(markerPositions));
                let hasChanged = false;

                if (draggedMarkerInfo.mode === 'vertical') {
                    const isR = chartType === 'recall';
                    const nY = isR ? activeGeneratedIndices.length : activeReferenceIndices.length;
                    const r = chartGrid.getBoundingClientRect();
                    let newY = Math.floor((1 - ((e.clientY - r.top) / r.height)) * nY);
                    newY = Math.max(0, Math.min(nY - 1, newY));
                    const marker = tempMarkers[chartType].find(m => m.id === id);
                    if (marker && marker.currentY !== newY) {
                        marker.currentY = newY;
                        hasChanged = true;
                    }
                } else if (draggedMarkerInfo.mode === 'horizontal') {
                    const isR = chartType === 'recall';
                    const nX = isR ? activeReferenceIndices.length : activeGeneratedIndices.length;
                    const r = chartGrid.getBoundingClientRect();
                    let hoverX = Math.floor(((e.clientX - r.left) / r.width) * nX);
                    hoverX = Math.max(0, Math.min(nX - 1, hoverX));
                    
                    if (hoverX !== id) {
                         draggedMarkerInfo.targetX = hoverX;
                         const sourceMarker = tempMarkers[chartType].find(m => m.id === id);
                         const targetMarker = tempMarkers[chartType].find(m => m.id === hoverX);
                         if (sourceMarker && targetMarker) {
                             // Simulate swap in temporary state
                             [sourceMarker.currentY, targetMarker.currentY] = [targetMarker.currentY, sourceMarker.currentY];
                             hasChanged = true;
                         }
                    } else {
                        draggedMarkerInfo.targetX = null;
                    }
                }

                if (hasChanged) {
                    showScorePreview(tempMarkers);
                }
            });
        }
        
        function handlePointMarkerMouseUp(e) {
            if (!isMarkerDragging) return;
            
            hideScorePreview(); // Hide preview on mouse up

            if (draggedMarkerInfo.mode === 'horizontal' && draggedMarkerInfo.targetX !== null) {
                const { chartType, id, targetX } = draggedMarkerInfo;
                const markers = markerPositions[chartType];
                const sourceMarker = markers.find(m => m.id === id);
                const targetMarker = markers.find(m => m.id === targetX);
                if (sourceMarker && targetMarker) {
                    // Perform the actual swap on the real state
                    [sourceMarker.currentY, targetMarker.currentY] = [targetMarker.currentY, sourceMarker.currentY];
                }
            } else if (draggedMarkerInfo.mode === 'vertical') {
                 const { chartType, id, chartGrid } = draggedMarkerInfo;
                 const isR = chartType === 'recall';
                 const nY = isR ? activeGeneratedIndices.length : activeReferenceIndices.length;
                 const r = chartGrid.getBoundingClientRect();
                 let newY = Math.floor((1 - ((e.clientY - r.top) / r.height)) * nY);
                 newY = Math.max(0, Math.min(nY - 1, newY));
                 const marker = markerPositions[chartType].find(m => m.id === id);
                 if (marker) {
                    marker.currentY = newY;
                 }
            }
            
            if (draggedMarkerInfo.element) draggedMarkerInfo.element.classList.remove('dragging');
            document.body.style.cursor = 'default';
            document.body.style.userSelect = '';
            hideChartTooltip();
            
            isMarkerDragging = false;
            draggedMarkerInfo = { chartType: null, id: null, element: null, chartGrid: null, startY: 0, startX: 0, mode: null, targetX: null };
            
            // Final render with the new state
            updateAndRenderAll();
        }
        
        // Segment management functions
        renderSegmentLists = function() { function populateList(ul, chunks, indices, type) { ul.innerHTML = ''; const activeSet = new Set(indices); const items = chunks.map((text, index) => { const li = document.createElement('li'); const isActive = activeSet.has(index); li.dataset.originalIndex = index; li.dataset.chunkType = type; const textSpan = document.createElement('span'); textSpan.textContent = `${type.slice(0,3).toUpperCase()} ${index}: ${text.substring(0,50)}${text.length > 50 ? '...' : ''}`; li.appendChild(textSpan); if (isActive) { li.setAttribute('draggable', true); const handle = document.createElement('i'); handle.className = 'fas fa-grip-vertical text-slate-400'; li.appendChild(handle); } li.classList.toggle('inactive-chunk', !isActive); li.onclick = () => toggleChunkActiveState(type, index); return { li, isActive, originalIndex: index }; }); indices.forEach(idx => ul.appendChild(items.find(it => it.originalIndex === idx).li)); items.forEach(it => { if (!it.isActive) ul.appendChild(it.li); }); } document.getElementById('activeRefChunkCount').textContent = activeReferenceIndices.length; document.getElementById('totalRefChunkCount').textContent = masterReferenceChunks.length; document.getElementById('activeGenChunkCount').textContent = activeGeneratedIndices.length; document.getElementById('totalGenChunkCount').textContent = masterGeneratedChunks.length; populateList(referenceSegmentsUl, masterReferenceChunks, activeReferenceIndices, 'reference'); populateList(generatedSegmentsUl, masterGeneratedChunks, activeGeneratedIndices, 'generated'); };
        handleSegmentDragStart = function(e) { if (!e.target.getAttribute('draggable')) return; draggedItemInfo.element = e.target; draggedItemInfo.originalIndex = parseInt(e.target.dataset.originalIndex); draggedItemInfo.type = e.target.dataset.chunkType; e.dataTransfer.effectAllowed = 'move'; e.dataTransfer.setData('text/plain', draggedItemInfo.originalIndex); setTimeout(() => e.target.classList.add('dragging'), 0); };
        handleSegmentDragOver = function(e) { e.preventDefault(); const ul = e.target.closest('ul'); if (!ul || (ul.id !== `${draggedItemInfo.type}SegmentsUl`)) return; if (!draggedItemInfo.placeholder) { draggedItemInfo.placeholder = document.createElement('li'); draggedItemInfo.placeholder.className = 'drag-placeholder'; draggedItemInfo.placeholder.textContent = 'Drop here'; } const li = e.target.closest('li:not(.inactive-chunk):not(.dragging)'); if (li && li.dataset.chunkType === draggedItemInfo.type) { const r = li.getBoundingClientRect(); ul.insertBefore(draggedItemInfo.placeholder, e.clientY > r.top + r.height / 2 ? li.nextSibling : li); } else if (!ul.querySelector('.drag-placeholder')) { const first = ul.querySelector('li[draggable="true"]'); if (first) ul.insertBefore(draggedItemInfo.placeholder, first); } };
        handleSegmentDrop = function(e) { e.preventDefault(); if (!draggedItemInfo.placeholder || !draggedItemInfo.placeholder.parentNode) return; const arr = draggedItemInfo.type === 'reference' ? activeReferenceIndices : activeGeneratedIndices; const from = arr.indexOf(draggedItemInfo.originalIndex); if(from > -1) arr.splice(from, 1); const items = Array.from(draggedItemInfo.placeholder.parentNode.children); const to = items.filter(li => li.getAttribute('draggable') === 'true' || li.classList.contains('drag-placeholder')).indexOf(draggedItemInfo.placeholder); arr.splice(to, 0, draggedItemInfo.originalIndex); draggedItemInfo.placeholder.remove(); initializeAppState(); updateAndRenderAll(); };
        handleSegmentDragEnd = function() { if (draggedItemInfo.element) draggedItemInfo.element.classList.remove('dragging'); if (draggedItemInfo.placeholder && draggedItemInfo.placeholder.parentNode) draggedItemInfo.placeholder.remove(); draggedItemInfo = { element: null, originalIndex: null, type: null, placeholder: null }; };
        
        toggleChunkActiveState = function(type, index) { let arr = (type === 'reference') ? activeReferenceIndices : activeGeneratedIndices; const pos = arr.indexOf(index); if (pos > -1) { if (arr.length > 1) arr.splice(pos, 1); else return; } else { arr.push(index); } activeReferenceIndices.sort((a,b)=>a-b); activeGeneratedIndices.sort((a,b)=>a-b); initializeAppState(); updateAndRenderAll(); };
        
        resetSegmentOrder = function(type) {
            if (type === 'generated') {
                activeGeneratedIndices = Array.from({ length: masterGeneratedChunks.length }, (_, i) => i);
                handleScenarioClick('optimal');
            } else {
                activeReferenceIndices = Array.from({ length: masterReferenceChunks.length }, (_, i) => i);
                initializeAppState();
                updateAndRenderAll();
            }
        };

        animateNumber = function(el, start, end, duration = 400) { if (Math.abs(end - start) < 0.001) { el.textContent = end.toFixed(el.id.includes("NasScore") || el.id.includes("Nas") || el.id.includes("f1") ? 3 : 2); return; } const frame = (ct) => { const elapsed = ct - st; const rawProgress = Math.min(elapsed / duration, 1); const progress = easeOutCubic(rawProgress); const current = start + (end - start) * progress; el.textContent = current.toFixed(el.id.includes("NasScore") || el.id.includes("Nas") || el.id.includes("f1") ? 3 : 2); if (rawProgress < 1) requestAnimationFrame(frame); }; const st = performance.now(); requestAnimationFrame(frame); };

        initializeAppState = function() { if (animationFrameId) cancelAnimationFrame(animationFrameId); ['precision', 'recall'].forEach(type => { const isR = type === 'recall', nX = isR ? activeReferenceIndices.length : activeGeneratedIndices.length, nY = isR ? activeGeneratedIndices.length : activeReferenceIndices.length; markerPositions[type] = []; if (nX === 0 || nY === 0) return; const sim = buildCurrentSimilarityMatrix(isR); for (let x=0; x<nX; x++) { const colSim = sim.map(row => row[x]), match = findBestMatchIndex(colSim); let y = match >= 0 ? match : Math.floor(nY/2); markerPositions[type].push({id: x, currentY: y});} }); const maxPrecisionY = activeReferenceIndices.length; const maxRecallY = activeGeneratedIndices.length; lctSlider.max = Math.max(0, Math.min(maxPrecisionY, maxRecallY) -1); if (parseInt(lctSlider.value) > parseInt(lctSlider.max)) lctSlider.value = lctSlider.max; };

    </script>
</body>
</html>