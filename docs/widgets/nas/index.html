<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complete Narrative Alignment Score (NAS) - Interactive Demo</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        
        /* --- SMOOTHNESS & PERFORMANCE ENHANCEMENTS --- */
        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Inter', sans-serif;
            transition: background 1.5s cubic-bezier(0.25, 0.1, 0.25, 1);
        }

        :root {
            --ease-out-quad: cubic-bezier(0.25, 0.46, 0.45, 0.94);
            --ease-out-cubic: cubic-bezier(0.215, 0.610, 0.355, 1.000);
        }

        /* --- Glassmorphism & Enhanced Card Styles --- */
        .interactive-card {
            background: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: transform 0.35s var(--ease-out-cubic), 
                        box-shadow 0.35s var(--ease-out-cubic), 
                        border-color 0.35s var(--ease-out-cubic);
            will-change: transform, box-shadow;
        }
        .interactive-card:hover {
            box-shadow: 0 12px 30px -8px rgba(0, 0, 0, 0.12), 0 8px 15px -8px rgba(0, 0, 0, 0.1);
            transform: translateY(-5px);
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        .demo-card { background: linear-gradient(135deg, rgba(255, 255, 255, 0.6) 0%, rgba(248, 250, 252, 0.5) 100%); border-color: rgba(226, 232, 240, 0.7); }
        .intro-card { background: linear-gradient(135deg, rgba(254, 252, 232, 0.6) 0%, rgba(254, 243, 199, 0.5) 100%); border-color: rgba(251, 191, 36, 0.5); }
        .metrics-card { background: linear-gradient(135deg, rgba(240, 249, 255, 0.6) 0%, rgba(219, 234, 254, 0.5) 100%); border-color: rgba(147, 197, 253, 0.6); }
        .formula-card { background: linear-gradient(135deg, rgba(237, 233, 254, 0.6) 0%, rgba(221, 214, 254, 0.5) 100%); border-color: rgba(196, 181, 253, 0.6); }

        .ghost-score {
            color: #9ca3af;
            font-weight: 700;
        }

        /* Tooltips */
        #chartTooltip {
            position: fixed; background: rgba(45, 55, 72, 0.9); backdrop-filter: blur(5px); color: white; padding: 8px 12px; border-radius: 6px;
            font-size: 0.8rem; z-index: 100; pointer-events: none; opacity: 0; 
            transition: opacity 0.25s var(--ease-out-quad), transform 0.25s var(--ease-out-quad);
            transform: scale(0.95);
        }
        #chartTooltip.visible {
            opacity: 1;
            transform: scale(1);
        }
        #chartTooltip.standard { border-left: 4px solid #22c55e; }
        #chartTooltip.lct-capped { border-left: 4px solid #f59e0b; }
        #chartTooltip.invalid { border-left: 4px solid #ef4444; }
        
        /* Segment List Styles */
        .segment-list ul li { 
            margin-bottom: 4px; line-height: 1.4; font-size: 0.8rem; color: #4b5563; padding: 4px 8px; border-radius: 0.375rem; 
            cursor: pointer; 
            transition: background-color 0.25s var(--ease-out-quad), border-color 0.25s var(--ease-out-quad), transform 0.25s var(--ease-out-quad), box-shadow 0.25s var(--ease-out-quad);
            border: 1px solid #e5e7eb; user-select: none; display: flex; justify-content: space-between; align-items: center; background: rgba(255,255,255,0.4); 
            will-change: background-color, transform;
        }
        .segment-list ul li:hover { background-color: #f0fdfa; border-color: #ccfbf1; transform: translateX(2px); }
        .segment-list ul li.highlight { background-color: #cffafe !important; border-color: #67e8f9 !important; transform: scale(1.03); box-shadow: 0 4px 12px rgba(103, 232, 249, 0.6); }
        .segment-list ul li.inactive-chunk { text-decoration: line-through; color: #9ca3af; background-color: #f3f4f6; }
        .segment-list ul li.inactive-chunk:hover { background-color: #e5e7eb; }
        .segment-list ul li.dragging { opacity: 0.5; background-color: #c7d2fe !important; cursor: grabbing; transform: scale(1.05); box-shadow: 0 8px 16px rgba(0,0,0,0.2); }
        @keyframes pulse { 0%, 100% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.02); opacity: 0.7; } }
        .drag-placeholder { height: 2.5em; background-color: #eef2ff; border: 2px dashed #a5b4fc; margin-bottom: 4px; border-radius: 0.375rem; display: flex; align-items: center; justify-content: center; font-size: 0.8rem; color: #64748b; animation: pulse 1.5s infinite; }

        .gen-marker {
            position: absolute; width: 12px; height: 12px; border-radius: 50%;
            background-color: #8b5cf6; border: 2px solid white;
            cursor: ns-resize; box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            z-index: 10;
            transition: transform 0.25s var(--ease-out-cubic), background-color 0.25s var(--ease-out-cubic), box-shadow 0.25s var(--ease-out-cubic);
            will-change: transform;
        }
        .gen-marker:hover { transform: scale(1.4); }
        .gen-marker.dragging { background-color: #a78bfa; box-shadow: 0 4px 8px rgba(0,0,0,0.4); transform: scale(1.5); cursor: grabbing; }

        .marker-penalty-label {
            position: absolute; top: 14px; left: 50%; transform: translateX(-50%);
            font-size: 0.7rem; color: #dc2626; font-weight: 600;
            background-color: rgba(255, 255, 255, 0.8); padding: 1px 3px;
            border-radius: 3px;
            display: none;
        }
        /* Make penalty visible via JS by adding a class, not direct style */
        .marker-penalty-label.visible {
            display: block;
        }

        /* Tour Styles */
        #tour-overlay { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 9998; 
            opacity: 0; transition: opacity 0.4s ease-in-out; pointer-events: none; 
        }
        .tour-highlight { 
            position: relative; z-index: 9999; 
            box-shadow: 0 0 0 9999px rgba(0,0,0,0.6), 0 0 20px rgba(255, 255, 255, 0.9); 
            border-radius: 0.5rem; transition: box-shadow 0.4s ease-in-out; 
        }
        #tour-callout { 
            position: absolute; background: white; color: #334155; padding: 1rem; border-radius: 0.5rem; 
            box-shadow: 0 5px 15px rgba(0,0,0,0.2); z-index: 10000; max-width: 300px; 
            border-left: 4px solid #3b82f6; 
            transition: opacity 0.3s var(--ease-out-cubic), transform 0.3s var(--ease-out-cubic);
            transform: translateY(10px);
            opacity: 0;
        }
        #tour-callout.visible {
            transform: translateY(0);
            opacity: 1;
        }
        #tour-callout button { 
            background-color: #3b82f6; color: white; padding: 0.5rem 1rem; border: none; border-radius: 0.375rem; cursor: pointer; 
            transition: background-color 0.2s var(--ease-out-quad), transform 0.2s var(--ease-out-quad); 
        }
        #tour-callout button:hover { background-color: #2563eb; transform: translateY(-1px); }
        
        .axis-label { position: absolute; font-size: 0.75rem; color: #475569; font-weight: 500; white-space: nowrap; z-index: 6; }
        .ideal-mapping-window { position: absolute; border: 2px solid #0d9488; background-color: rgba(20, 184, 166, 0.2); box-sizing: border-box; z-index: 1; transition: all 0.3s var(--ease-out-quad); pointer-events: none; border-radius: 0.25rem; }
        .lct-padding-window { position: absolute; background-color: rgba(253, 224, 71, 0.15); box-sizing: border-box; z-index: 0; transition: all 0.2s ease-out; pointer-events: none; border: 1px dashed #facc15; border-radius: 0.25rem; }
        .chart-grid-background { background-image: linear-gradient(to right, #e2e8f0 1px, transparent 1px), linear-gradient(to bottom, #e2e8f0 1px, transparent 1px); }
        .ideal-paths-svg, .actual-path-svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .ideal-paths-svg { z-index: 2; }
        .actual-path-svg { z-index: 4; }  
        .floor-path-line, .ceil-path-line { stroke-width: 2px; fill: none; stroke-dasharray: 4; transition: d 0.3s var(--ease-out-quad); }
        .floor-path-line { stroke: #0ea5e9; }
        .ceil-path-line { stroke: #ec4899; }
        .actual-path-line { stroke: #8b5cf6; stroke-width: 2.5px; fill: none; }

        /* Path segment color styling */
        .path-segment-standard { 
            stroke: #22c55e; 
            stroke-width: 3.5px; 
            fill: none; 
            transition: stroke 0.3s var(--ease-out-quad);
        }
        .path-segment-lct-capped { 
            stroke: #f59e0b; 
            stroke-width: 3.5px; 
            fill: none; 
            transition: stroke 0.3s var(--ease-out-quad);
        }
        .path-segment-invalid { 
            stroke: #ef4444; 
            stroke-width: 3.5px; 
            fill: none; 
            stroke-dasharray: 5, 5; 
            transition: stroke 0.3s var(--ease-out-quad);
        }

        /* Path animation */
        .path-segment-animated {
            stroke-dasharray: 1000;
            stroke-dashoffset: 1000;
            animation: draw-path 600ms var(--ease-out-cubic) forwards;
        }
        @keyframes draw-path {
            to { stroke-dashoffset: 0; }
        }
        .preset-btn { transition: all 0.2s var(--ease-out-quad); background: linear-gradient(135deg, #0d9488 0%, #14b8a6 100%); }
        .preset-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(13, 148, 136, 0.3); }
        .pattern-bg { background-image: radial-gradient(circle at 2px 2px, rgba(20, 184, 166, 0.1) 1px, transparent 0); background-size: 20px 20px; }
        .step-number { background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%); color: white; width: 2rem; height: 2rem; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 0.875rem; flex-shrink: 0; }
        details summary { cursor: pointer; user-select: none; transition: color 0.2s var(--ease-out-quad); }
        details summary:hover { color: #1d4ed8; }
        details summary::-webkit-details-marker { display: none; }
        details summary .summary-icon { display: inline-block; margin-right: 0.5rem; transition: transform 0.25s var(--ease-out-cubic); }
        details[open] summary .summary-icon { transform: rotate(90deg); }

    </style>
</head>
<body class="h-full text-slate-700 antialiased pattern-bg">
    <div id="app-background" class="fixed inset-0 z-[-1] transition-all duration-1000"></div>
    <div id="tour-overlay"></div>
    <div id="chartTooltip"></div>

    <main class="w-full max-w-8xl mx-auto p-4 sm:p-6 lg:p-8 min-h-screen">
        
        <!-- Header -->
        <div class="text-center mb-8 relative">
            <div class="flex items-center justify-center mb-4">
                <div class="bg-teal-100 text-teal-800 px-3 py-1 rounded-full text-xs font-semibold uppercase tracking-wide mr-2">Complete System</div>
                <div class="bg-amber-100 text-amber-800 px-3 py-1 rounded-full text-xs font-semibold">NAS-D + NAS-L + Regularizer</div>
            </div>
            <h1 class="text-3xl sm:text-4xl font-bold bg-gradient-to-r from-teal-600 to-teal-800 bg-clip-text text-transparent">Complete Narrative Alignment Score (NAS)</h1>
            <p class="mt-3 text-lg text-slate-600 max-w-3xl mx-auto">A comprehensive evaluation system combining chronological order (NAS-D), narrative flow (NAS-L), and structural coverage (Window Regularizer) into a single robust metric.</p>
            <button id="start-tour-btn" class="absolute top-0 right-0 bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-full transition-transform transform hover:scale-105">
                <i class="fas fa-magic mr-2"></i>Start Tour
            </button>
        </div>
        
        <!-- Introduction Section -->
        <div class="mb-8">
            <div id="tour-step-1" class="intro-card interactive-card rounded-xl p-6">
                <div class="flex items-center mb-4"><i class="fas fa-sitemap text-amber-600 text-xl mr-3"></i><h2 class="text-xl font-semibold text-amber-800">Complete NAS Calculation Pipeline</h2></div>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
                    <div class="bg-white bg-opacity-60 p-4 rounded-lg"><h3 class="font-semibold text-amber-700 mb-2 flex items-center"><i class="fas fa-crosshairs text-amber-500 mr-2"></i>NAS-D Component</h3><p class="text-sm text-slate-700">Distance-based chronological alignment penalties. Measures how far each generated chunk is from its ideal position in the reference sequence.</p></div>
                    <div class="bg-white bg-opacity-60 p-4 rounded-lg"><h3 class="font-semibold text-amber-700 mb-2 flex items-center"><i class="fas fa-route text-amber-500 mr-2"></i>NAS-L Component</h3><p class="text-sm text-slate-700">Line-based narrative flow assessment. Evaluates the smoothness and calculability of alignment paths between text segments.</p></div>
                    <div class="bg-white bg-opacity-60 p-4 rounded-lg"><h3 class="font-semibold text-amber-700 mb-2 flex items-center"><i class="fas fa-window-maximize text-amber-500 mr-2"></i>Window Regularizer</h3><p class="text-sm text-slate-700">Structural coverage penalty that prevents artificially high scores when content is significantly reduced or simplified.</p></div>
                </div>
                <details id="tour-step-2" class="mb-4">
                    <summary class="font-semibold text-amber-700 mb-3 flex items-center"><i class="fas fa-chevron-right summary-icon"></i>Complete NAS Formula & Pipeline</summary>
                    <div class="mt-4 space-y-6 ml-6 border-l-2 border-slate-200 pl-6">
                        
                        <!-- Step 1 -->
                        <div class="flex items-start">
                            <div class="step-number mr-4">1</div>
                            <div>
                                <h4 class="font-semibold text-slate-800 mb-1">Calculate NAS-D (Precision & Recall)</h4>
                                <p class="text-sm text-slate-600 mb-2">Distance-based penalties for chronological misalignment. Purple markers show actual positions vs expected mapping windows.</p>
                                <div class="bg-blue-50 p-3 rounded-lg text-xs">
                                    <code>NAS-D = 1 - (total_penalty / max_possible_penalty)</code>
                                </div>
                            </div>
                        </div>

                        <!-- Step 2 -->
                        <div class="flex items-start">
                            <div class="step-number mr-4">2</div>
                            <div>
                                <h4 class="font-semibold text-slate-800 mb-1">Calculate NAS-L (Precision & Recall)</h4>
                                <p class="text-sm text-slate-600 mb-2">Path-based flow assessment using ideal band comparison. Colored segments show calculability status.</p>
                                <div class="bg-purple-50 p-3 rounded-lg text-xs">
                                    <code>NAS-L = normalize(actual_path_length, floor_path, ceil_path)</code>
                                </div>
                            </div>
                        </div>

                        <!-- Step 3 -->
                        <div class="flex items-start">
                            <div class="step-number mr-4">3</div>
                            <div>
                                <h4 class="font-semibold text-slate-800 mb-1">Combine with F1 Score</h4>
                                <p class="text-sm text-slate-600 mb-2">Harmonic mean of precision and recall for both NAS-D and NAS-L, then combined into overall F1.</p>
                                <div class="bg-amber-50 p-3 rounded-lg text-xs">
                                    <code>F1_NAS = 2 * (F1_NAS-D * F1_NAS-L) / (F1_NAS-D + F1_NAS-L)</code>
                                </div>
                            </div>
                        </div>

                        <!-- Step 4 -->
                        <div class="flex items-start">
                            <div class="step-number mr-4">4</div>
                            <div>
                                <h4 class="font-semibold text-slate-800 mb-1">Apply Window Regularizer</h4>
                                <p class="text-sm text-slate-600 mb-2">Prevents artificially high scores from oversimplified content by penalizing inefficient window coverage.</p>
                                <div class="bg-red-50 p-3 rounded-lg text-xs">
                                    <code>Final_NAS = (F1_NAS - Regularizer) / (1 - Regularizer)</code>
                                </div>
                            </div>
                        </div>
                    </div>
                </details>
            </div>
        </div>

        <!-- Main Content Area -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <div class="lg:col-span-2 space-y-8">
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                    <div id="tour-step-4" class="demo-card interactive-card rounded-xl p-4">
                        <div class="text-center mb-4"><div class="inline-flex items-center bg-teal-100 text-teal-800 px-3 py-1 rounded-full text-xs font-semibold mb-2"><i class="fas fa-crosshairs mr-1"></i>PRECISION ANALYSIS</div><h2 class="text-lg font-bold text-slate-800">Gen → Ref Alignment</h2></div>
                        <div class="relative w-full max-w-md mx-auto pt-4 pb-36 pl-20 pr-4">
                            <div class="absolute top-1/2 -left-8 -translate-y-16 -rotate-90 font-semibold text-sm text-slate-600 whitespace-nowrap">Reference Chunks</div>
                            <div class="absolute bottom-24 left-1/2 -translate-x-1/4 font-semibold text-sm text-slate-600">Generated Chunks</div>
                            <div class="relative w-full aspect-square">
                                <div id="precisionChartGrid" class="absolute inset-0 bg-white rounded-lg chart-grid-background border border-slate-200">
                                    <div id="precisionLctPaddingContainer"></div>
                                    <div id="precisionIdealMappingContainer"></div>
                                    <svg class="ideal-paths-svg" id="precisionIdealPathsSvg"></svg>
                                    <div id="precisionMarkerContainer"></div>
                                    <svg class="actual-path-svg" id="precisionActualPathSvg"></svg>
                                    <div id="precisionAxisLabelContainerY"></div>
                                    <div id="precisionAxisLabelContainerX"></div>
                                </div>
                            </div>
                            <div id="precisionChartMetrics" class="absolute -bottom-2 left-0 right-0 grid grid-cols-2 gap-x-4 gap-y-1 text-center text-xs text-slate-600 bg-white/80 p-2 rounded-md">
                                <div><span>NAS-D:</span><br><span id="precisionNasD" class="font-bold text-blue-600">0.000</span> <span id="precisionNasDPreview" class="ghost-score"></span></div>
                                <div><span>NAS-L:</span><br><span id="precisionNasL" class="font-bold text-purple-600">0.000</span> <span id="precisionNasLPreview" class="ghost-score"></span></div>
                                <div class="col-span-2"><span>Combined:</span><br><span id="precisionCombined" class="font-bold text-teal-600 text-sm">0.000</span> <span id="precisionCombinedPreview" class="ghost-score"></span></div>
                            </div>
                        </div>
                    </div>
                    <div class="demo-card interactive-card rounded-xl p-4">
                        <div class="text-center mb-4"><div class="inline-flex items-center bg-amber-100 text-amber-800 px-3 py-1 rounded-full text-xs font-semibold mb-2"><i class="fas fa-search mr-1"></i>RECALL ANALYSIS</div><h2 class="text-lg font-bold text-slate-800">Ref → Gen Alignment</h2></div>
                        <div class="relative w-full max-w-md mx-auto pt-4 pb-36 pl-20 pr-4">
                            <div class="absolute top-1/2 -left-8 -translate-y-16 -rotate-90 font-semibold text-sm text-slate-600 whitespace-nowrap">Generated Chunks</div>
                            <div class="absolute bottom-24 left-1/2 -translate-x-1/4 font-semibold text-sm text-slate-600">Reference Chunks</div>
                            <div class="relative w-full aspect-square">
                                <div id="recallChartGrid" class="absolute inset-0 bg-white rounded-lg chart-grid-background border border-slate-200">
                                    <div id="recallLctPaddingContainer"></div>
                                    <div id="recallIdealMappingContainer"></div>
                                    <svg class="ideal-paths-svg" id="recallIdealPathsSvg"></svg>
                                    <div id="recallMarkerContainer"></div>
                                    <svg class="actual-path-svg" id="recallActualPathSvg"></svg>
                                    <div id="recallAxisLabelContainerY"></div>
                                    <div id="recallAxisLabelContainerX"></div>
                                </div>
                            </div>
                            <div id="recallChartMetrics" class="absolute -bottom-2 left-0 right-0 grid grid-cols-2 gap-x-4 gap-y-1 text-center text-xs text-slate-600 bg-white/80 p-2 rounded-md">
                                <div><span>NAS-D:</span><br><span id="recallNasD" class="font-bold text-blue-600">0.000</span> <span id="recallNasDPreview" class="ghost-score"></span></div>
                                <div><span>NAS-L:</span><br><span id="recallNasL" class="font-bold text-purple-600">0.000</span> <span id="recallNasLPreview" class="ghost-score"></span></div>
                                <div class="col-span-2"><span>Combined:</span><br><span id="recallCombined" class="font-bold text-amber-600 text-sm">0.000</span> <span id="recallCombinedPreview" class="ghost-score"></span></div>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="tour-step-5" class="demo-card interactive-card rounded-xl p-6">
                    <div class="text-center mb-6"><h3 class="text-lg font-semibold text-slate-800 mb-2">Interactive Narrative Management</h3><p class="text-sm text-slate-500">Drag to reorder chunks • Click to activate/deactivate • Drag purple markers to adjust alignments</p></div>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div class="segment-list" id="referenceSegments"><div class="flex justify-between items-center mb-2"><h4 class="text-md font-semibold text-slate-700 flex items-center"><i class="fas fa-list text-teal-600 mr-2"></i>Reference (<span id="activeRefChunkCount">0</span>/<span id="totalRefChunkCount">0</span>)</h4><button id="resetRefOrderBtn" title="Reset Reference Order" class="text-slate-500 hover:text-blue-600 transition"><i class="fas fa-undo text-sm"></i></button></div><ul id="referenceSegmentsUl" class="space-y-1 h-72 overflow-y-auto pr-2 bg-slate-50/50 rounded p-2 border"></ul></div>
                        <div class="segment-list" id="generatedSegments"><div class="flex justify-between items-center mb-2"><h4 class="text-md font-semibold text-slate-700 flex items-center"><i class="fas fa-list text-amber-600 mr-2"></i>Generated (<span id="activeGenChunkCount">0</span>/<span id="totalGenChunkCount">0</span>)</h4><button id="resetGenOrderBtn" title="Reset Generated Order" class="text-slate-500 hover:text-blue-600 transition"><i class="fas fa-undo text-sm"></i></button></div><ul id="generatedSegmentsUl" class="space-y-1 h-72 overflow-y-auto pr-2 bg-slate-50/50 rounded p-2 border"></ul></div>
                    </div>
                    <!-- Advanced Interactions Tip Section -->
                    <details class="mt-4">
                        <summary class="font-semibold text-sm text-slate-600 hover:text-blue-600">Explore Advanced Interactions <i class="fas fa-chevron-down summary-icon text-xs"></i></summary>
                        <div class="mt-2 space-y-3 text-xs text-slate-600 bg-slate-50/50 p-4 rounded-lg border">
                            <p>▶ <strong>Complete System Testing:</strong> See how NAS-D, NAS-L, and Window Regularizer work together.</p>
                            <p>▶ <strong>Drag Purple Markers:</strong> Adjust individual alignments to see real-time impact on all components.</p>
                            <p>▶ <strong>Window Regularizer Effect:</strong> Deactivate chunks to see how the regularizer prevents artificially high scores.</p>
                            <p>▶ <strong>Component Comparison:</strong> Notice how different misalignment types affect NAS-D vs NAS-L differently.</p>
                        </div>
                    </details>
                </div>
            </div>

            <!-- Controls Panel -->
            <div class="lg:col-span-1">
                <div class="sticky top-6 space-y-6">
                    <div id="tour-step-6" class="metrics-card interactive-card rounded-xl p-6">
                        <h3 class="text-lg font-semibold text-blue-800 mb-4 flex items-center"><i class="fas fa-trophy text-blue-600 mr-2"></i>Complete NAS Score</h3>
                        <div class="space-y-4">
                            <div class="text-center bg-green-50/70 p-3 rounded-lg border border-green-200">
                                <label class="block text-sm font-medium text-green-700 mb-1">Final NAS Score</label>
                                <span id="finalCompleteNas" class="text-4xl font-bold text-green-600">0.000</span>
                                <span id="finalCompleteNasPreview" class="text-4xl ghost-score"></span>
                                <p class="text-xs text-slate-500 mt-1">Regularized comprehensive score</p>
                            </div>
                               <div class="grid grid-cols-2 gap-4">
                                  <div class="text-center">
                                      <label class="block text-sm font-medium text-blue-700 mb-1">F1 NAS-D</label>
                                      <span id="overallNasDF1" class="text-2xl font-bold text-blue-600">0.000</span>
                                      <span id="overallNasDF1Preview" class="text-2xl ghost-score"></span>
                                      <p class="text-xs text-slate-500 mt-1">Distance alignment</p>
                                  </div>
                                  <div class="text-center">
                                      <label class="block text-sm font-medium text-purple-700 mb-1">F1 NAS-L</label>
                                      <span id="overallNasLF1" class="text-2xl font-bold text-purple-600">0.000</span>
                                      <span id="overallNasLF1Preview" class="text-2xl ghost-score"></span>
                                      <p class="text-xs text-slate-500 mt-1">Flow alignment</p>
                                  </div>
                               </div>
                               <div class="grid grid-cols-2 gap-4">
                                  <div class="text-center">
                                      <label class="block text-sm font-medium text-amber-700 mb-1">Combined F1</label>
                                      <span id="combinedF1NAS" class="text-xl font-bold text-amber-600">0.000</span>
                                      <span id="combinedF1NASPreview" class="text-xl ghost-score"></span>
                                      <p class="text-xs text-slate-500 mt-1">Before regularizer</p>
                                  </div>
                                  <div class="text-center">
                                      <label class="block text-sm font-medium text-red-700 mb-1">Regularizer</label>
                                      <span id="windowRegularizer" class="text-xl font-bold text-red-600">0.000</span>
                                       <span id="windowRegularizerPreview" class="text-xl ghost-score"></span>
                                      <p class="text-xs text-slate-500 mt-1">Coverage penalty</p>
                                  </div>
                               </div>
                        </div>
                    </div>
                    <div id="tour-step-lct" class="formula-card interactive-card rounded-xl p-6">
                        <h3 class="text-lg font-semibold text-purple-800 mb-3 flex items-center"><i class="fas fa-sliders-h text-purple-600 mr-2"></i>LCT Parameter</h3>
                        <div class="flex items-center gap-4 mb-4"><label for="lctSlider" class="text-sm font-medium text-purple-700">Tolerance:</label><input type="range" id="lctSlider" min="0" max="5" value="0" step="1" class="flex-1 h-2 bg-purple-200 rounded-lg appearance-none cursor-pointer"><span id="lctValueDisplay" class="text-lg font-bold text-purple-600 w-8 text-center">0</span></div>
                        <div id="lctDescription" class="bg-purple-50/70 p-3 rounded-lg border border-purple-200 text-xs text-purple-700"></div>
                    </div>
                    <div id="tour-step-3" class="demo-card interactive-card rounded-xl p-6">
                        <h3 class="text-lg font-semibold text-slate-800 mb-4 flex items-center"><i class="fas fa-magic text-purple-600 mr-2"></i>Chronological Scenarios</h3>
                        <div class="grid grid-cols-2 gap-3">
                            <button class="preset-btn w-full text-white px-3 py-2 rounded-lg text-xs font-medium" onclick="handleScenarioClick('optimal')">
                                <i class="fas fa-sort-numeric-down mr-2"></i>Optimal
                            </button>
                            <button class="preset-btn w-full text-white px-3 py-2 rounded-lg text-xs font-medium" onclick="handleScenarioClick('neighborSwap')">
                                <i class="fas fa-exchange-alt mr-2"></i>Neighbor Swaps
                            </button>
                            <button class="preset-btn w-full text-white px-3 py-2 rounded-lg text-xs font-medium" onclick="handleScenarioClick('reverse')">
                                <i class="fas fa-sort-numeric-up mr-2"></i>Reverse
                            </button>
                            <button class="preset-btn w-full text-white px-3 py-2 rounded-lg text-xs font-medium" onclick="handleScenarioClick('minorDisorders')">
                                <i class="fas fa-random mr-2"></i>Minor Disorders
                            </button>
                            <button class="preset-btn w-full text-white px-3 py-2 rounded-lg text-xs font-medium" onclick="handleScenarioClick('majorDisorder')">
                                <i class="fas fa-exclamation-triangle mr-2"></i>Major Disorder
                            </button>
                            <button class="preset-btn w-full text-white px-3 py-2 rounded-lg text-xs font-medium" onclick="handleScenarioClick('rotateHalf')">
                                <i class="fas fa-sync-alt mr-2"></i>Rotate Half
                            </button>
                        </div>
                        <!-- Div for Dynamic Scenario Tips -->
                        <div id="scenarioTip" class="mt-4 bg-slate-50/70 p-3 rounded-lg border border-slate-200 text-xs text-slate-600 transition-all duration-300">
                           <p><strong>Tip:</strong> Start with "Neighbor Swaps" to see how NAS detects subtle flow disruptions!</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <script>
        // --- DATA ---
        const masterReferenceChunks = [
            "The old market bell rings starting a busy market", "Vendors open their bright stalls in the busy square while the smell of fresh bread fills the air", "A young seller shouts out good deals as curious people gather around", "The steady ring of the bell sets the pace for the day", "A wise old vendor stops by his stall giving advice to those who pass by", "As the market gets busy the bell rings again at midday reminding everyone of the community spirit", "A light rain briefly slows the crowd but everyone is spirit stays strong", "Local storytellers tell simple tales that catch everyone is attention", "As evening comes the old bell rings one last time perfectly echoing the start of the day"
        ];
        const masterGeneratedChunks = [
            "At first light the town s antique bell clangs signalling that the market is open for business", "Stalls spring to life all around the square their owners lifting colourful awnings while the warm scent of freshbaked bread drifts through the crowd", "A lively young hawker calls out bargains drawing curious shoppers closer", "That bell keeps time for everyone its steady peal guiding the morning rush", "Nearby an older merchant pauses at his booth offering bits of seasoned advice to anyone who will listen", "When noon rolls around the bell sounds again a friendly reminder of the shared spirit that holds the place together", "A brief shower scatters a few people but the mood never really fades", "Storytellers soon reclaim the moment with simple tales that pull listeners back in", "As dusk settles the same bell rings one final note neatly bookending the day it helped begin"
        ];
        const masterSimilarityValues = [ 
            [0.737, 0.360, 0.286, 0.461, 0.284, 0.388, 0.062, 0.139, 0.396], [0.462, 0.783, 0.295, 0.269, 0.264, 0.227, 0.142, 0.158, 0.232], [0.244, 0.238, 0.814, 0.105, 0.337, 0.138, 0.120, 0.169, 0.084], [0.555, 0.259, 0.100, 0.734, 0.137, 0.593, 0.167, 0.199, 0.656], [0.258, 0.254, 0.293, 0.168, 0.774, 0.169, 0.110, 0.165, 0.151], [0.569, 0.340, 0.248, 0.483, 0.241, 0.764, 0.180, 0.216, 0.507], [0.134, 0.219, 0.106, 0.243, 0.133, 0.239, 0.689, 0.183, 0.177], [0.261, 0.259, 0.218, 0.266, 0.274, 0.286, 0.220, 0.679, 0.257], [0.537, 0.277, 0.059, 0.549, 0.218, 0.608, 0.192, 0.212, 0.869]
        ];

        // --- STATE & DOM ---
        let activeReferenceIndices = [], activeGeneratedIndices = [];
        let markerPositions = { precision: [], recall: [] };
        let actualPathPositions = { precision: [], recall: [] };
        let actualPathSegments = { precision: [], recall: [] }; // **ADDED** To store segment info
        let currentLct = 0;
        let animationFrameId = null;
        let isMarkerDragging = false; 
        let draggedItemInfo = { element: null, originalIndex: null, type: null, placeholder: null };
        let draggedMarkerInfo = { chartType: null, id: null, element: null, chartGrid: null, startY: 0 };
        
        const lctSlider = document.getElementById('lctSlider');
        const lctValueDisplay = document.getElementById('lctValueDisplay');
        const lctDescription = document.getElementById('lctDescription');
        const referenceSegmentsUl = document.getElementById('referenceSegmentsUl');  
        const generatedSegmentsUl = document.getElementById('generatedSegmentsUl');
        const resetGenOrderBtn = document.getElementById('resetGenOrderBtn');
        const resetRefOrderBtn = document.getElementById('resetRefOrderBtn');
        const chartTooltip = document.getElementById('chartTooltip');
        const appBackground = document.getElementById('app-background');
        
        const charts = {
            precision: {
                grid: document.getElementById('precisionChartGrid'), idealContainer: document.getElementById('precisionIdealMappingContainer'),
                lctContainer: document.getElementById('precisionLctPaddingContainer'), markerContainer: document.getElementById('precisionMarkerContainer'),
                idealPathsSvg: document.getElementById('precisionIdealPathsSvg'), actualPathSvg: document.getElementById('precisionActualPathSvg'),
                axisX: document.getElementById('precisionAxisLabelContainerX'), axisY: document.getElementById('precisionAxisLabelContainerY'),
            },
            recall: {
                grid: document.getElementById('recallChartGrid'), idealContainer: document.getElementById('recallIdealMappingContainer'),
                lctContainer: document.getElementById('recallLctPaddingContainer'), markerContainer: document.getElementById('recallMarkerContainer'),
                idealPathsSvg: document.getElementById('recallIdealPathsSvg'), actualPathSvg: document.getElementById('recallActualPathSvg'),
                axisX: document.getElementById('recallAxisLabelContainerX'), axisY: document.getElementById('recallAxisLabelContainerY'),
            }
        };

        // Easing function for smoother animations
        const easeOutCubic = t => 1 - Math.pow(1 - t, 3);
        
        // --- TOUR MANAGER ---
        const tourManager = {
            isActive: false,
            currentStep: 0,
            overlay: document.getElementById('tour-overlay'),
            steps: [
                { selector: '#tour-step-1', text: 'Welcome! This shows the complete NAS system that combines distance, flow, and coverage metrics.', position: 'bottom' },
                { selector: '#tour-step-2', text: 'Click to see the complete pipeline formula and how all components work together.', position: 'bottom'},
                { selector: '#tour-step-3', text: 'Try different scenarios to see how they affect all three components simultaneously.', position: 'left', action: () => simulateNeighborSwaps() },
                { selector: '#tour-step-4', text: 'These charts show both NAS-D and NAS-L working together. Purple markers can be dragged to see real-time effects.', position: 'top' },
                { selector: '#tour-step-5', text: 'Manage narrative content here. Deactivating chunks demonstrates how the window regularizer works.', position: 'top' },
                { selector: '#tour-step-lct', text: 'LCT affects both NAS-D penalties and NAS-L path calculations simultaneously.', position: 'left' },
                { selector: '#tour-step-6', text: 'The final comprehensive score combines all components with the window regularizer to prevent gaming.', position: 'left' }
            ],

            start: function() {
                this.isActive = true;
                this.currentStep = 0;
                this.overlay.style.pointerEvents = 'auto';
                this.overlay.style.opacity = '1';
                this.showStep();
            },

            next: function() {
                this.cleanupCurrentStep();
                this.currentStep++;
                if (this.currentStep < this.steps.length) {
                    if (this.steps[this.currentStep-1].action) {
                       this.steps[this.currentStep-1].action();
                    }
                    setTimeout(() => this.showStep(), 400);
                } else {
                    this.end();
                }
            },
            
            showStep: function() {
                const step = this.steps[this.currentStep];
                const targetElement = document.querySelector(step.selector);
                if (!targetElement) { this.end(); return; }

                targetElement.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });

                setTimeout(() => {
                    targetElement.classList.add('tour-highlight');
                    
                    const callout = document.createElement('div');
                    callout.id = 'tour-callout';
                    callout.innerHTML = `<p class="text-sm mb-4">${step.text}</p><div class="flex justify-end"><button onclick="tourManager.next()">Next &rarr;</button></div>`;
                    document.body.appendChild(callout);
                    
                    const targetRect = targetElement.getBoundingClientRect();
                    const calloutRect = callout.getBoundingClientRect();
                    const margin = 15;

                    const scrollY = window.scrollY || document.documentElement.scrollTop;
                    const scrollX = window.scrollX || document.documentElement.scrollLeft;

                    let top, left;

                    switch (step.position) {
                        case 'bottom':
                            top = targetRect.bottom + scrollY + margin;
                            left = targetRect.left + scrollX + (targetRect.width / 2) - (calloutRect.width / 2);
                            break;
                        case 'top':
                            top = targetRect.top + scrollY - calloutRect.height - margin;
                            left = targetRect.left + scrollX + (targetRect.width / 2) - (calloutRect.width / 2);
                            break;
                        case 'left':
                            top = targetRect.top + scrollY + (targetRect.height / 2) - (calloutRect.height / 2);
                            left = targetRect.left + scrollX - calloutRect.width - margin;
                            break;
                        case 'right':
                            top = targetRect.top + scrollY + (targetRect.height / 2) - (calloutRect.height / 2);
                            left = targetRect.right + scrollX + margin;
                            break;
                        default:
                            top = targetRect.bottom + scrollY + margin;
                            left = targetRect.left + scrollX;
                    }
                    
                    const viewportRight = scrollX + window.innerWidth;
                    const viewportBottom = scrollY + window.innerHeight;

                    if (left < scrollX + margin) left = scrollX + margin;
                    if (left + calloutRect.width > viewportRight - margin) left = viewportRight - calloutRect.width - margin;
                    if (top < scrollY + margin) top = scrollY + margin;
                    if (top + calloutRect.height > viewportBottom - margin) top = viewportBottom - calloutRect.height - margin;
                    
                    callout.style.top = `${top}px`;
                    callout.style.left = `${left}px`;

                    requestAnimationFrame(() => {
                        callout.classList.add('visible');
                    });
                }, 350);
            },
            
            cleanupCurrentStep: function() {
                const oldHighlight = document.querySelector('.tour-highlight');
                if (oldHighlight) oldHighlight.classList.remove('tour-highlight');
                const oldCallout = document.getElementById('tour-callout');
                if (oldCallout) oldCallout.remove();
            },

            end: function() {
                this.cleanupCurrentStep();
                this.isActive = false;
                this.overlay.style.opacity = '0';
                setTimeout(() => this.overlay.style.pointerEvents = 'none', 400);
            }
        };

        // --- DYNAMIC BACKGROUND ---
        function updateDynamicBackground(finalScore) {
            const score = isNaN(finalScore) ? 0 : finalScore;
            const hue = 120 * score;
            const saturation = 30 + 40 * score;
            const lightness = 85 + 10 * score;
            const startColor = `hsl(170, ${saturation-10}%, ${lightness-5}%)`;
            const endColor = `hsl(190, ${saturation}%, ${lightness}%)`;
            appBackground.style.background = `linear-gradient(135deg, ${startColor} 0%, ${endColor} 100%)`;
        }
        
        // --- CORE LOGIC FUNCTIONS ---
        function _calculate_f1(precision, recall) {
            if (precision + recall === 0) return 0.0;
            return (2 * precision * recall) / (precision + recall);
        }

        function buildCurrentSimilarityMatrix(isForRecall) {
            const numRef = activeReferenceIndices.length;
            const numGen = activeGeneratedIndices.length;
            if (numRef === 0 || numGen === 0) return [];

            const matrix = Array.from({ length: isForRecall ? numGen : numRef }, () => Array(isForRecall ? numRef : numGen).fill(0));

            for (let i = 0; i < (isForRecall ? numGen : numRef); i++) {
                for (let j = 0; j < (isForRecall ? numRef : numGen); j++) {
                    const rIdx = isForRecall ? activeReferenceIndices[j] : activeReferenceIndices[i];
                    const gIdx = isForRecall ? activeGeneratedIndices[i] : activeGeneratedIndices[j];
                    matrix[i][j] = masterSimilarityValues[rIdx][gIdx];
                }
            }

            if (!isForRecall) {
                return matrix[0].map((_, colIndex) => matrix.map(row => row[colIndex]));
            }
            return matrix[0].map((_, colIndex) => matrix.map(row => row[colIndex]));
        }
        
        function get_mapping_windows_generic(lenX, lenY) {
            if (lenX === 0 || lenY === 0) return [];
            const isYLonger = lenY >= lenX;
            const longerLen = isYLonger ? lenY : lenX;
            const shorterLen = isYLonger ? lenX : lenY;
            const slope = longerLen / shorterLen;
            const mappingWindowSize = Math.ceil(slope);
            let direct_windows = [];
            for (let i = 0; i < shorterLen; i++) {
                const idx_point = i * slope;
                const start = Math.floor(idx_point);
                const end = Math.min(start + mappingWindowSize, longerLen);
                direct_windows.push({ start, end });
            }
            if (isYLonger) return direct_windows;
            let windows_for_X_items = Array(lenX).fill(null);
            for (let x_idx = 0; x_idx < lenX; x_idx++) {
                let mappedYIndices = [];
                direct_windows.forEach((y_window_on_x_axis, y_idx) => {
                    if (x_idx >= y_window_on_x_axis.start && x_idx < y_window_on_x_axis.end) { mappedYIndices.push(y_idx); }
                });
                if (mappedYIndices.length > 0) {
                    windows_for_X_items[x_idx] = { start: Math.min(...mappedYIndices), end: Math.max(...mappedYIndices) + 1 };
                } else { 
                    const proportionalYPos = Math.max(0, Math.min(lenY - 1, Math.floor((x_idx / lenX) * lenY)));
                    windows_for_X_items[x_idx] = { start: proportionalYPos, end: Math.min(proportionalYPos + 1, lenY) };
                }
            }
            return windows_for_X_items.map(w => w ? ({start: w.start, end: Math.max(w.start + 1, w.end)}) : null);
        }

        function findBestMatchIndex(similarityColumn) {
            if (!similarityColumn || similarityColumn.length === 0) return -1;
            let maxVal = -Infinity, maxIdx = -1;
            similarityColumn.forEach((val, idx) => { if (val > maxVal) { maxVal = val; maxIdx = idx; } });
            return maxIdx;
        }

        function findBestMatchWithContextJS(similarityArray, mappingWindow, cutoff, ctrl) {
            let maxVal = -Infinity; let maxIdx = -1;
            if (!similarityArray || similarityArray.length === 0) return { bestMatchIndex: -1 };
            similarityArray.forEach((val, idx) => { if (val > maxVal) { maxVal = val; maxIdx = idx; } });
            if (maxIdx === -1) return { bestMatchIndex: -1 };

            const contextRange = 1 - cutoff;
            const contextWindowApplied = maxVal > 0 && (contextRange - (1 - maxVal)) > 0;
            const contextValueDrop = (contextWindowApplied && maxVal !== 0) ? ((contextRange - (1 - maxVal)) / maxVal) / ctrl : 0.0;
            const contextThreshold = maxVal - contextValueDrop;
            
            const candidateIndices = []; const candidateValues = [];
            similarityArray.forEach((val, idx) => { if (val >= contextThreshold) { candidateIndices.push(idx); candidateValues.push(val); } });

            if (candidateIndices.length <= 1 || !mappingWindow) {
                return { bestMatchIndex: candidateIndices.length === 1 ? candidateIndices[0] : maxIdx };
            }

            const { start, end } = mappingWindow; 
            let minDistance = Infinity; let bestMatchIndexToReturn = maxIdx; let highestSimInMinDist = -Infinity;

            candidateIndices.forEach((candIdx, i) => {
                const dist = candIdx >= start && candIdx < end ? 0 : Math.min(Math.abs(candIdx - start), Math.abs(candIdx - (end - 1)));
                if (dist < minDistance) {
                    minDistance = dist;
                    bestMatchIndexToReturn = candIdx;
                    highestSimInMinDist = candidateValues[i];
                } else if (dist === minDistance) {
                    if (candidateValues[i] > highestSimInMinDist) {
                        highestSimInMinDist = candidateValues[i];
                        bestMatchIndexToReturn = candIdx;
                    }
                }
            });
            return { bestMatchIndex: bestMatchIndexToReturn };
        }

        // NAS-D Distance calculations
        function calculatePenaltiesAndNAS(chartType) {
            const isRecall = chartType === 'recall';
            const sourceLen = isRecall ? activeReferenceIndices.length : activeGeneratedIndices.length;
            const targetLen = isRecall ? activeGeneratedIndices.length : activeReferenceIndices.length;
            const markers = markerPositions[chartType];
            const idealWindows = get_mapping_windows_generic(sourceLen, targetLen);

            if (sourceLen === 0 || targetLen === 0 || markers.length === 0) return { actualPenalty: 0, maxPenalty: 0, nas: 1.0, markerPenalties: [] };

            let totalActualPenalty = 0;
            const markerPenalties = [];
            for (let i = 0; i < sourceLen; i++) {
                const marker = markers[i]; const window = idealWindows[i];
                if (!marker || !window) continue;
                const markerY = marker.currentY; const windowStart = window.start; const windowEnd = window.end - 1; 
                const lctAdjustedStart = Math.max(0, windowStart - currentLct);
                const lctAdjustedEnd = Math.min(targetLen - 1, windowEnd + currentLct);
                let penalty = 0;
                if (markerY < lctAdjustedStart) { penalty = windowStart - markerY; } 
                else if (markerY > lctAdjustedEnd) { penalty = markerY - windowEnd; }
                totalActualPenalty += penalty;
                markerPenalties.push({ id: marker.id, penalty: penalty });
            }
            const maxPenaltyPerUnit = targetLen > 1 ? targetLen - 1 : 0;
            const maxTotalPenalty = sourceLen * maxPenaltyPerUnit;
            const nas = (maxTotalPenalty > 0) ? Math.max(0, 1 - (totalActualPenalty / maxTotalPenalty)) : 1.0;
            return { actualPenalty: totalActualPenalty, maxPenalty: maxTotalPenalty, nas: nas, markerPenalties: markerPenalties };
        }

        // NAS-L Line calculations
        function computeIdealNarrativeLineBandJS(mappingWindows, numX, numY) {
            const n_windows = mappingWindows.length;
            if (n_windows === 0 || numX === 0 || numY === 0) {
                return { shortest_line: 0.0, longest_line: 0.0, floor_path: [], ceil_path: [], floor_path_dy_map: {} };
            }
            
            let dp_min = [], dp_max = [], pred_min = [], pred_max = [];
            for(let i=0; i<n_windows; ++i) {
                if(!mappingWindows[i]) {
                    dp_min.push([]); dp_max.push([]); pred_min.push([]); pred_max.push([]);
                    continue;
                }
                const {start, end} = mappingWindows[i];
                const h = end - start;
                dp_min.push(Array(h).fill(Infinity));
                dp_max.push(Array(h).fill(-Infinity));
                pred_min.push(Array(h).fill(-1));
                pred_max.push(Array(h).fill(-1));
            }

            if(dp_min[0]) {
                for(let y=0; y<dp_min[0].length; ++y) {
                    dp_min[0][y] = 0;
                    dp_max[0][y] = 0;
                }
            }
            
            for(let i=1; i<n_windows; ++i) {
                if(!mappingWindows[i] || !mappingWindows[i-1]) continue;
                const {start: cur_s, end: cur_e} = mappingWindows[i];
                const {start: prev_s, end: prev_e} = mappingWindows[i-1];
                for(let y_cur=0; y_cur<cur_e-cur_s; ++y_cur) {
                    for(let y_prev=0; y_prev<prev_e-prev_s; ++y_prev) {
                        const dist = Math.sqrt(1 + (cur_s+y_cur - (prev_s+y_prev))**2);
                        if(dp_min[i-1][y_prev] !== Infinity && dp_min[i-1][y_prev] + dist < dp_min[i][y_cur]) {
                            dp_min[i][y_cur] = dp_min[i-1][y_prev] + dist;
                            pred_min[i][y_cur] = y_prev;
                        }
                        if(dp_max[i-1][y_prev] !== -Infinity && dp_max[i-1][y_prev] + dist > dp_max[i][y_cur]) {
                            dp_max[i][y_cur] = dp_max[i-1][y_prev] + dist;
                            pred_max[i][y_cur] = y_prev;
                        }
                    }
                }
            }

            let shortest_line = dp_min[n_windows-1] ? Math.min(...dp_min[n_windows-1]) : 0;
            let longest_line = dp_max[n_windows-1] ? Math.max(...dp_max[n_windows-1]) : 0;
            let shortest_end_y = dp_min[n_windows-1] ? dp_min[n_windows-1].indexOf(shortest_line) : -1;
            let longest_end_y = dp_max[n_windows-1] ? dp_max[n_windows-1].indexOf(longest_line) : -1;

            if(shortest_line === Infinity || shortest_end_y === -1) shortest_line = 0;
            if(longest_line === -Infinity || longest_end_y === -1) longest_line = 0;

            let floor_path = [], ceil_path = [];
            let current_y_min = shortest_end_y;
            let current_y_max = longest_end_y;

            for(let i = n_windows-1; i>=0; --i) {
                if(!mappingWindows[i]) continue;
                if(current_y_min !== -1 && pred_min[i] && pred_min[i][current_y_min] !== undefined) {
                    floor_path.unshift({x: i, y: mappingWindows[i].start + current_y_min});
                    current_y_min = pred_min[i][current_y_min];
                }
                if(current_y_max !== -1 && pred_max[i] && pred_max[i][current_y_max] !== undefined) {
                    ceil_path.unshift({x: i, y: mappingWindows[i].start + current_y_max});
                    current_y_max = pred_max[i][current_y_max];
                }
            }
            
            const dyMap = {};
            if(floor_path.length > 1) {
                for(let i=0; i<floor_path.length-1; ++i) {
                    const x_pos = floor_path[i].x;
                    const dy = floor_path[i+1].y - floor_path[i].y;
                    dyMap[x_pos] = dy;
                }
            }
            
            return { shortest_line, longest_line, floor_path, ceil_path, floor_path_dy_map: dyMap };
        }

        function computeActualLineLengthJS(actualPath, totalRefChunks, totalGenChunks, lctValue, dyMap) {
            if (!actualPath || actualPath.length <= 1) return { totalLength: 0.0, segments: [] };

            let len = 0;
            const segments = [];
            const sortedPath = [...actualPath].sort((a,b) => a.x - b.x);
            const ratio = totalGenChunks > 0 ? totalRefChunks / totalGenChunks : 0;
            const mappingWindowHeight = Math.ceil(ratio);
            const ratioDecimalPart = ratio - Math.floor(ratio);
            let lct_window_base;
            if (totalRefChunks <= totalGenChunks) {
                lct_window_base = mappingWindowHeight;
            } else {
                lct_window_base = (ratioDecimalPart > 0 && ratioDecimalPart <= 0.5) ? (2 * mappingWindowHeight) - 2 : (2 * mappingWindowHeight) - 1;
            }
            lct_window_base = Math.max(0, lct_window_base);

            let expanded_lct_window;
            if (totalRefChunks <= totalGenChunks) {
                expanded_lct_window = lctValue > 0 ? lct_window_base + (mappingWindowHeight * lctValue) : lct_window_base;
            } else {
                if (ratioDecimalPart > 0 && ratioDecimalPart <= 0.5) {
                    expanded_lct_window = lctValue > 0 ? lct_window_base + ((mappingWindowHeight - 1) * lctValue) : lct_window_base;
                } else {
                    expanded_lct_window = lctValue > 0 ? lct_window_base + (mappingWindowHeight * lctValue) : lct_window_base;
                }
            }

            for (let i = 0; i < sortedPath.length - 1; i++) {
                const p1 = sortedPath[i], p2 = sortedPath[i+1];
                const dx = p2.x - p1.x, dyRaw = p2.y - p1.y;
                if (dx <= 0) continue;
                
                const dyValue = lctValue > 0 ? Math.abs(dyRaw) : dyRaw;
                let segmentLength = 0;
                let calculation_method = "invalid";
                
                if (dyValue <= lct_window_base && dyValue >= 0) {
                    segmentLength = Math.sqrt(dx**2 + dyRaw**2);
                    calculation_method = "standard";
                } 
                else if (lctValue > 0 && dyValue > lct_window_base && dyValue <= expanded_lct_window) {
                    if (dyMap && dyMap[p1.x] !== undefined) {
                        const floorDy = dyMap[p1.x];
                        segmentLength = Math.sqrt(dx**2 + floorDy**2);
                        calculation_method = "lct-capped";
                    }
                }
                len += segmentLength;
                segments.push({ start: p1, end: p2, length: segmentLength, calculation_method: calculation_method, dy: dyRaw, threshold: lct_window_base, expanded_threshold: expanded_lct_window });
            }
            return { totalLength: len, segments: segments };
        }

        function calculateLineNAS(floor, ceil, actual) {
            if (floor === 0 && ceil === 0) return 1.0;
            if (actual >= floor && actual <= ceil) return 1.0;
            if (actual < floor) return floor > 0 ? actual / floor : 0.0;
            return actual > 0 ? ceil / actual : 0.0;
        }

        // Window Regularizer calculation
        function calculateWindowRegularizer(refLen, genLen) {
            const mappingWindows = get_mapping_windows_generic(genLen, refLen);
            let totalMappingWindowArea = 0;
            for (const window of mappingWindows) {
                if (window) {
                    const mappingWindowHeight = window.end - window.start;
                    totalMappingWindowArea += mappingWindowHeight * 1;
                }
            }
            const timelineArea = refLen * genLen;
            const maxLen = Math.max(refLen, genLen);
            const minAreaVal = maxLen > 0 ? 1 / maxLen : 0;
            
            let windowRegularizerVal;
            if (timelineArea > 0 && minAreaVal < 0.5 && (0.5 - minAreaVal) > 1e-9 ) {
                windowRegularizerVal = ( (totalMappingWindowArea / timelineArea) - minAreaVal) / (0.5 - minAreaVal);
                windowRegularizerVal = Math.max(0, Math.min(1, windowRegularizerVal));
            } else if (timelineArea > 0 && minAreaVal >= 0.5) {
                windowRegularizerVal = (totalMappingWindowArea / timelineArea <= minAreaVal + 1e-9) ? 0 : 1;
            } else {
                windowRegularizerVal = 0;
            }
            
            return {
                windowRegularizer: windowRegularizerVal,
                timelineArea: timelineArea,
                totalMappingWindowArea: totalMappingWindowArea,
                minArea: minAreaVal
            };
        }

        function regularizeNAS(nasF1, windowRegularizer) {
            const nasRegularized = nasF1 - windowRegularizer;
            if (nasRegularized <= 0) return 0.0;
            if (Math.abs(1 - windowRegularizer) < 1e-9) return 0.0;
            return nasRegularized / (1 - windowRegularizer);
        }

        function initializeActualPath(simMatrix, mappingWindowsForX, sourceLen, targetLen) {
            const newPath = [];
            if (sourceLen === 0 || targetLen === 0 || simMatrix.length === 0 || simMatrix[0].length === 0) {
                 return newPath;
            }
            for (let x_idx = 0; x_idx < sourceLen; x_idx++) {
                const columnSimilarity = simMatrix[x_idx];
                const currentMappingWindow = mappingWindowsForX[x_idx];
                const matchInfo = findBestMatchWithContextJS(columnSimilarity, currentMappingWindow, 0.6, 4.0);
                let y_match_idx = matchInfo.bestMatchIndex;
                if (y_match_idx === -1) {
                    y_match_idx = currentMappingWindow ? Math.floor((currentMappingWindow.start + currentMappingWindow.end) / 2) : Math.floor(targetLen / 2);
                }
                newPath.push({ x: x_idx, y: y_match_idx });
            }
            return newPath;
        }

        // --- SCENARIO PRESET FUNCTIONS ---
        const scenarioTips = {
            optimal: '<strong>Tip:</strong> The alignment is perfectly optimal. Try dragging points to see how the score changes.',
            neighborSwap: '<strong>Tip:</strong> Global order is maintained, but local flow is disrupted. Notice the score drop from these small swaps.',
            reverse: '<strong>Tip:</strong> The alignment is completely reversed. Test how the score changes with and without LCT enabled.',
            minorDisorders: '<strong>Tip:</strong> Even a few out-of-place segments can significantly impact the narrative flow score.',
            majorDisorder: '<strong>Tip:</strong> With major chaos, the paths are too long and discontinuous, resulting in low scores.',
            rotateHalf: '<strong>Tip:</strong> Local chronology is mostly preserved, but global order is wrong. The score drops significantly.'
        };

        function handleScenarioClick(scenarioType) { 
            document.getElementById('scenarioTip').innerHTML = scenarioTips[scenarioType];
            let targetGenOrder = [...activeGeneratedIndices].sort((a,b) => a-b); 
            const n = targetGenOrder.length; 
            switch(scenarioType) { 
                case 'optimal': break; 
                case 'neighborSwap': for(let i=0; i < n - 1; i+=2) { [targetGenOrder[i], targetGenOrder[i+1]] = [targetGenOrder[i+1], targetGenOrder[i]]; } break; 
                case 'reverse': targetGenOrder.reverse(); break; 
                case 'minorDisorders': targetGenOrder.forEach((_, i) => { if (Math.random() > 0.6) { const swapWith = (i + (Math.random() > 0.5 ? 1 : -1) + n) % n; [targetGenOrder[i], targetGenOrder[swapWith]] = [targetGenOrder[swapWith], targetGenOrder[i]]; } }); break; 
                case 'majorDisorder': const reorderPattern = [2, 5, 1, 7, 0, 4, 8, 3, 6]; targetGenOrder = reorderPattern.slice(0, n); break; 
                case 'rotateHalf': const mid = Math.floor(n/2); targetGenOrder = [...targetGenOrder.slice(mid), ...targetGenOrder.slice(0, mid)]; break; 
            } 
            animateScenarioTransition(targetGenOrder); 
        }

        function animateScenarioTransition(targetGenOrder) {
            const startOrder = [...activeGeneratedIndices];
            const duration = 600;
            const startTime = performance.now();
            
            function easeOutCubic(t) {
                return 1 - Math.pow(1 - t, 3);
            }
            
            function animate(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easedProgress = easeOutCubic(progress);
                
                // Interpolate positions
                const currentOrder = startOrder.map((startVal, i) => {
                    const targetVal = targetGenOrder[i];
                    return Math.round(startVal + (targetVal - startVal) * easedProgress);
                });
                
                // Update state
                activeGeneratedIndices = currentOrder;
                initializeAppState();
                updateAndRenderAll();
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            }
            
            requestAnimationFrame(animate);
        }

        function updateScenarioTip(message) {
            document.getElementById('scenarioTip').innerHTML = `<p><strong>Tip:</strong> ${message}</p>`;
        }

        // --- PREVIEW (GHOST) FUNCTIONS ---
        function showScorePreview(tempMarkers, tempPaths) {
             currentLct = parseInt(lctSlider.value);
             const nRef = activeReferenceIndices.length, nGen = activeGeneratedIndices.length;

             // Calculate NAS-D for both charts
             const precNasDResult = calculatePenaltiesForMarkers('precision', tempMarkers.precision);
             const recNasDResult = calculatePenaltiesForMarkers('recall', tempMarkers.recall);
             
             // Calculate NAS-L for both charts
             const precMappingWindows = get_mapping_windows_generic(nGen, nRef);
             const precIdealBand = computeIdealNarrativeLineBandJS(precMappingWindows, nGen, nRef);
             const precPathInfo = computeActualLineLengthJS(tempPaths.precision, nRef, nGen, currentLct, precIdealBand.floor_path_dy_map);
             const precNasL = calculateLineNAS(precIdealBand.shortest_line, precIdealBand.longest_line, precPathInfo.totalLength);
             
             const recMappingWindows = get_mapping_windows_generic(nRef, nGen);
             const recIdealBand = computeIdealNarrativeLineBandJS(recMappingWindows, nRef, nGen);
             const recPathInfo = computeActualLineLengthJS(tempPaths.recall, nGen, nRef, currentLct, recIdealBand.floor_path_dy_map);
             const recNasL = calculateLineNAS(recIdealBand.shortest_line, recIdealBand.longest_line, recPathInfo.totalLength);

             // Calculate F1 scores
             const nasDf1 = _calculate_f1(precNasDResult.nas, recNasDResult.nas);
             const nasLf1 = _calculate_f1(precNasL, recNasL);
             const combinedF1 = _calculate_f1(nasDf1, nasLf1);
             
             // Calculate regularizer and final score
             const regResults = calculateWindowRegularizer(nRef, nGen);
             const finalNAS = regularizeNAS(combinedF1, regResults.windowRegularizer);

             // Update precision chart metrics
             document.getElementById('precisionNasDPreview').textContent = `→ ${precNasDResult.nas.toFixed(3)}`;
             document.getElementById('precisionNasLPreview').textContent = `→ ${precNasL.toFixed(3)}`;
             document.getElementById('precisionCombinedPreview').textContent = `→ ${_calculate_f1(precNasDResult.nas, precNasL).toFixed(3)}`;
             
             // Update recall chart metrics
             document.getElementById('recallNasDPreview').textContent = `→ ${recNasDResult.nas.toFixed(3)}`;
             document.getElementById('recallNasLPreview').textContent = `→ ${recNasL.toFixed(3)}`;
             document.getElementById('recallCombinedPreview').textContent = `→ ${_calculate_f1(recNasDResult.nas, recNasL).toFixed(3)}`;

             // Update overall metrics
             document.getElementById('overallNasDF1Preview').textContent = `→ ${nasDf1.toFixed(3)}`;
             document.getElementById('overallNasLF1Preview').textContent = `→ ${nasLf1.toFixed(3)}`;
             document.getElementById('combinedF1NASPreview').textContent = `→ ${combinedF1.toFixed(3)}`;
             document.getElementById('windowRegularizerPreview').textContent = `→ ${regResults.windowRegularizer.toFixed(3)}`;
             document.getElementById('finalCompleteNasPreview').textContent = `→ ${finalNAS.toFixed(3)}`;
        }

        function hideScorePreview() {
            const previewElements = ['precisionNasDPreview', 'precisionNasLPreview', 'precisionCombinedPreview', 
                                     'recallNasDPreview', 'recallNasLPreview', 'recallCombinedPreview',
                                     'overallNasDF1Preview', 'overallNasLF1Preview', 'combinedF1NASPreview', 
                                     'windowRegularizerPreview', 'finalCompleteNasPreview'];
            previewElements.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.textContent = '';
            });
        }

        function calculatePenaltiesForMarkers(chartType, tempMarkers) {
            const isRecall = chartType === 'recall';
            const sourceLen = isRecall ? activeReferenceIndices.length : activeGeneratedIndices.length;
            const targetLen = isRecall ? activeGeneratedIndices.length : activeReferenceIndices.length;
            const idealWindows = get_mapping_windows_generic(sourceLen, targetLen);

            if (sourceLen === 0 || targetLen === 0 || tempMarkers.length === 0) return { nas: 1.0 };

            let totalActualPenalty = 0;
            for (let i = 0; i < sourceLen; i++) {
                const marker = tempMarkers[i]; const window = idealWindows[i];
                if (!marker || !window) continue;
                const markerY = marker.currentY; const windowStart = window.start; const windowEnd = window.end - 1; 
                const lctAdjustedStart = Math.max(0, windowStart - currentLct);
                const lctAdjustedEnd = Math.min(targetLen - 1, windowEnd + currentLct);
                let penalty = 0;
                if (markerY < lctAdjustedStart) { penalty = windowStart - markerY; } 
                else if (markerY > lctAdjustedEnd) { penalty = markerY - windowEnd; }
                totalActualPenalty += penalty;
            }
            const maxPenaltyPerUnit = targetLen > 1 ? targetLen - 1 : 0;
            const maxTotalPenalty = sourceLen * maxPenaltyPerUnit;
            const nas = (maxTotalPenalty > 0) ? Math.max(0, 1 - (totalActualPenalty / maxTotalPenalty)) : 1.0;
            return { nas: nas };
        }

        // --- RENDERING FUNCTIONS ---
        function renderSegmentLists() {
            function populateList(ul, masterChunks, activeIndices, type) {
                ul.innerHTML = '';
                const activeSet = new Set(activeIndices);
                const listItems = masterChunks.map((text, index) => {
                    const li = document.createElement('li');
                    const isActive = activeSet.has(index);
                    li.dataset.originalIndex = index;
                    li.dataset.chunkType = type;
                    const textSpan = document.createElement('span');
                    textSpan.textContent = `${type.slice(0,3).toUpperCase()} ${index}: ${text.substring(0,50)}${text.length > 50 ? '...' : ''}`;
                    li.appendChild(textSpan);
                    if (isActive) {
                        li.setAttribute('draggable', true);
                        const handle = document.createElement('i');
                        handle.className = 'fas fa-grip-vertical text-slate-400';
                        li.appendChild(handle);
                    }
                    li.classList.toggle('inactive-chunk', !isActive);
                    li.addEventListener('click', () => toggleChunkActiveState(type, index));
                    return { li, isActive, originalIndex: index };
                });

                activeIndices.forEach(activeIndex => {
                    const item = listItems.find(it => it.originalIndex === activeIndex);
                    if (item) ul.appendChild(item.li);
                });
                
                listItems.forEach(item => {
                    if (!item.isActive) ul.appendChild(item.li);
                });
            }
            document.getElementById('activeRefChunkCount').textContent = activeReferenceIndices.length;
            document.getElementById('totalRefChunkCount').textContent = masterReferenceChunks.length;
            document.getElementById('activeGenChunkCount').textContent = activeGeneratedIndices.length;
            document.getElementById('totalGenChunkCount').textContent = masterGeneratedChunks.length;

            populateList(referenceSegmentsUl, masterReferenceChunks, activeReferenceIndices, 'reference');
            populateList(generatedSegmentsUl, masterGeneratedChunks, activeGeneratedIndices, 'generated');
        }
        
        function renderChart(chartType, results) {
            const chartUI = charts[chartType];
            const isRecall = chartType === 'recall';
            const sourceLen = isRecall ? activeReferenceIndices.length : activeGeneratedIndices.length;
            const targetLen = isRecall ? activeGeneratedIndices.length : activeReferenceIndices.length;
            
            chartUI.idealContainer.innerHTML = ''; chartUI.lctContainer.innerHTML = '';
            chartUI.markerContainer.innerHTML = ''; chartUI.axisX.innerHTML = ''; chartUI.axisY.innerHTML = '';
            chartUI.idealPathsSvg.innerHTML = ''; chartUI.actualPathSvg.innerHTML = '';

            requestAnimationFrame(() => {
                if (sourceLen > 0 && targetLen > 0) {
                    chartUI.grid.style.backgroundImage = `linear-gradient(to right, #e2e8f0 1px, transparent 1px), linear-gradient(to bottom, #e2e8f0 1px, transparent 1px)`;
                    chartUI.grid.style.backgroundSize = `calc(100% / ${sourceLen}) calc(100% / ${targetLen})`;
                } else { chartUI.grid.style.backgroundImage = 'none'; }
            });
            if (sourceLen === 0 || targetLen === 0) return;
            
            const idealWindows = get_mapping_windows_generic(sourceLen, targetLen);

            idealWindows.forEach((window, x_idx) => {
                if (!window) return;
                const startY = window.start; const endY = window.end; const height = endY - startY;
                const idealDiv = document.createElement('div');
                idealDiv.className = 'ideal-mapping-window';
                idealDiv.style.left = `calc(${x_idx} * 100% / ${sourceLen})`; idealDiv.style.width = `calc(100% / ${sourceLen})`;
                idealDiv.style.bottom = `calc(${startY} * 100% / ${targetLen})`; idealDiv.style.height = `calc(${height} * 100% / ${targetLen})`;
                chartUI.idealContainer.appendChild(idealDiv);
                
                const lctStartY = Math.max(0, startY - currentLct); const lctEndY = Math.min(targetLen, endY + currentLct);
                const lctHeight = lctEndY - lctStartY;
                const lctDiv = document.createElement('div');
                lctDiv.className = 'lct-padding-window';
                lctDiv.style.left = idealDiv.style.left; lctDiv.style.width = idealDiv.style.width;
                lctDiv.style.bottom = `calc(${lctStartY} * 100% / ${targetLen})`; lctDiv.style.height = `calc(${lctHeight} * 100% / ${targetLen})`;
                chartUI.lctContainer.appendChild(lctDiv);
            });

            const { markerPenalties } = results.nasD;
            const penaltyMap = new Map(markerPenalties.map(p => [p.id, p.penalty]));
            markerPositions[chartType].forEach(marker => {
                const markerDiv = document.createElement('div');
                markerDiv.className = 'gen-marker'; markerDiv.dataset.id = marker.id; markerDiv.dataset.chartType = chartType;
                const penalty = penaltyMap.get(marker.id) || 0;
                const penaltyLabel = document.createElement('span');
                penaltyLabel.className = 'marker-penalty-label';
                if (penalty > 0) { 
                    penaltyLabel.textContent = `-${penalty}`;
                    penaltyLabel.classList.add('visible');
                }
                markerDiv.appendChild(penaltyLabel);
                markerDiv.style.left = `calc(${(marker.id + 0.5)} * 100% / ${sourceLen} - 6px)`;
                markerDiv.style.bottom = `calc(${(marker.currentY + 0.5)} * 100% / ${targetLen} - 6px)`;
                chartUI.markerContainer.appendChild(markerDiv);
            });

            const yIndices = isRecall ? activeGeneratedIndices : activeReferenceIndices;
            const xIndices = isRecall ? activeReferenceIndices : activeGeneratedIndices;
            
            const yStep = Math.max(1, Math.ceil(targetLen / 8));
            for (let i = 0; i < targetLen; i += yStep) {
                const lbl = document.createElement('div'); lbl.className = 'axis-label'; lbl.textContent = yIndices[i];
                lbl.style.left = '-1rem'; lbl.style.top = `calc(100% - (${i}*100%/${targetLen}) - (50%/${targetLen}))`;
                lbl.style.transform = 'translateY(-50%) translateX(-100%)'; chartUI.axisY.appendChild(lbl);
            }
            if (targetLen > 1 && (targetLen-1) % yStep !== 0) {
                const lbl = document.createElement('div'); lbl.className = 'axis-label'; lbl.textContent = yIndices[targetLen-1];
                lbl.style.left = '-1rem'; lbl.style.top = `calc(100% - (${targetLen-1}*100%/${targetLen}) - (50%/${targetLen}))`;
                lbl.style.transform = 'translateY(-50%) translateX(-100%)'; chartUI.axisY.appendChild(lbl);
            }
            const xStep = Math.max(1, Math.ceil(sourceLen / 8));
            for (let i = 0; i < sourceLen; i += xStep) {
                const lbl = document.createElement('div'); lbl.className = 'axis-label'; lbl.textContent = xIndices[i];
                lbl.style.bottom = '-1.5rem'; lbl.style.left = `calc(${i}*100%/${sourceLen} + 50%/${sourceLen})`;
                lbl.style.transform = 'translateX(-50%)'; chartUI.axisX.appendChild(lbl);
            }
            if (sourceLen > 1 && (sourceLen-1) % xStep !== 0) {
                const lbl = document.createElement('div'); lbl.className = 'axis-label'; lbl.textContent = xIndices[sourceLen - 1];
                lbl.style.bottom = '-1.5rem'; lbl.style.left = `calc(${sourceLen - 1}*100%/${sourceLen} + 50%/${sourceLen})`;
                lbl.style.transform = 'translateX(-50%)'; chartUI.axisX.appendChild(lbl);
            }

            // Render SVG paths for Line NAS
            const chartWidth = chartUI.grid.clientWidth;
            const chartHeight = chartUI.grid.clientHeight;
            
            // Clear the SVG first
            chartUI.idealPathsSvg.innerHTML = '';
            chartUI.actualPathSvg.innerHTML = '';
            
            const drawIdealPath = (svg, pathData, className) => {
                if (!pathData || pathData.length === 0 || !(chartWidth > 0) || !(chartHeight > 0)) return;
                const points = pathData.map(p => `${(p.x + 0.5) * (chartWidth / sourceLen)},${chartHeight - ((p.y + 0.5) * (chartHeight / targetLen))}`).join(' ');
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
                line.setAttribute('points', points); 
                line.setAttribute('class', className);
                svg.appendChild(line);
            };

            const drawSegmentedPath = (svg, pathData, segments) => {
                if (!pathData || pathData.length === 0 || !segments || !(chartWidth > 0) || !(chartHeight > 0)) return;
                
                // Clear existing paths
                svg.innerHTML = '';
                
                for (let i = 0; i < pathData.length - 1; i++) {
                    const startPoint = pathData[i];
                    const endPoint = pathData[i + 1];
                    
                    // Convert to screen coordinates
                    const x1 = (startPoint.x + 0.5) * (chartWidth / sourceLen);
                    const y1 = chartHeight - ((startPoint.y + 0.5) * (chartHeight / targetLen));
                    const x2 = (endPoint.x + 0.5) * (chartWidth / sourceLen);
                    const y2 = chartHeight - ((endPoint.y + 0.5) * (chartHeight / targetLen));
                    
                    // Create line segment
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', x1);
                    line.setAttribute('y1', y1);
                    line.setAttribute('x2', x2);
                    line.setAttribute('y2', y2);
                    
                    // Determine segment type and apply appropriate class
                    let segmentClass = 'path-segment-standard';
                    if (segments[i]) {
                        switch (segments[i].calculation_method) {
                            case 'lct-capped':
                                segmentClass = 'path-segment-lct-capped';
                                break;
                            case 'invalid':
                                segmentClass = 'path-segment-invalid';
                                break;
                            default:
                                segmentClass = 'path-segment-standard';
                        }
                    }
                    
                    line.setAttribute('class', `${segmentClass} path-segment-animated`);
                    
                    // Add animation delay for staggered effect
                    line.style.animationDelay = `${i * 50}ms`;
                    
                    // Add tooltip functionality
                    line.addEventListener('mouseenter', (e) => {
                        const segmentInfo = segments[i] || { calculation_method: 'standard' };
                        const tooltip = document.getElementById('chartTooltip');
                        
                        // Set tooltip content
                        let typeText = segmentInfo.calculation_method === 'lct-capped' ? 'LCT-Capped' : 
                                      segmentInfo.calculation_method === 'invalid' ? 'Invalid' : 'Standard';
                        tooltip.innerHTML = `<strong>Segment ${i + 1}</strong><br>Type: ${typeText}`;
                        
                        // Remove existing type classes and add new one
                        tooltip.classList.remove('standard', 'lct-capped', 'invalid');
                        tooltip.classList.add(segmentInfo.calculation_method || 'standard');
                        tooltip.classList.add('visible');
                        
                        // Position tooltip
                        const rect = svg.getBoundingClientRect();
                        tooltip.style.left = e.clientX + 10 + 'px';
                        tooltip.style.top = e.clientY - 10 + 'px';
                    });
                    
                    line.addEventListener('mouseleave', () => {
                        const tooltip = document.getElementById('chartTooltip');
                        tooltip.classList.remove('visible');
                    });
                    
                    svg.appendChild(line);
                }
            };

            if (results.nasL && results.nasL.idealBand) {
                drawIdealPath(chartUI.idealPathsSvg, results.nasL.idealBand.floor_path, 'floor-path-line');
                drawIdealPath(chartUI.idealPathsSvg, results.nasL.idealBand.ceil_path, 'ceil-path-line');
            }
            // Use segmented path for actual path with color coding
            if (actualPathSegments[chartType] && actualPathSegments[chartType].length > 0) {
                drawSegmentedPath(chartUI.actualPathSvg, actualPathPositions[chartType], actualPathSegments[chartType]);
            } else {
                drawIdealPath(chartUI.actualPathSvg, actualPathPositions[chartType], 'actual-path-line');
            }
        }
        
        // --- EVENT HANDLERS ---
        function handleSegmentDragStart(e) {
            if (!e.target.getAttribute('draggable')) return;
            draggedItemInfo.element = e.target;
            draggedItemInfo.originalIndex = parseInt(e.target.dataset.originalIndex);
            draggedItemInfo.type = e.target.dataset.chunkType;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', draggedItemInfo.originalIndex);
            setTimeout(() => e.target.classList.add('dragging'), 0);
        }

        function handleSegmentDragOver(e) {
            e.preventDefault();
            const listUl = e.target.closest('ul');
            if (!listUl || (listUl.id !== `${draggedItemInfo.type}SegmentsUl`)) return;
            if (!draggedItemInfo.placeholder) {
                draggedItemInfo.placeholder = document.createElement('li');
                draggedItemInfo.placeholder.className = 'drag-placeholder';
                draggedItemInfo.placeholder.textContent = 'Drop here';
            }
            const targetLi = e.target.closest('li:not(.inactive-chunk):not(.dragging)');
            if (targetLi && targetLi.dataset.chunkType === draggedItemInfo.type) {
                const rect = targetLi.getBoundingClientRect();
                const isAfter = e.clientY > rect.top + rect.height / 2;
                listUl.insertBefore(draggedItemInfo.placeholder, isAfter ? targetLi.nextSibling : targetLi);
            } else if (!listUl.querySelector('.drag-placeholder')) {
                const firstActive = listUl.querySelector('li[draggable="true"]');
                if (firstActive) {
                    listUl.insertBefore(draggedItemInfo.placeholder, firstActive);
                } else {
                    listUl.appendChild(draggedItemInfo.placeholder);
                }
            }
        }
        
        function handleSegmentDrop(e) {
            e.preventDefault();
            if (!draggedItemInfo.element || !draggedItemInfo.placeholder || !draggedItemInfo.placeholder.parentNode) return;

            const activeIndicesArray = draggedItemInfo.type === 'reference' ? activeReferenceIndices : activeGeneratedIndices;
            
            // Find the index to move the item to
            const listItems = Array.from(draggedItemInfo.placeholder.parentNode.children);
            const toIndex = listItems.filter(li => li.getAttribute('draggable') === 'true' || li === draggedItemInfo.placeholder).indexOf(draggedItemInfo.placeholder);

            // Remove the item from its original position
            const fromIndex = activeIndicesArray.indexOf(draggedItemInfo.originalIndex);
            if (fromIndex > -1) {
                activeIndicesArray.splice(fromIndex, 1);
            }
            
            // Insert it at the new position
            activeIndicesArray.splice(toIndex, 0, draggedItemInfo.originalIndex);
            
            draggedItemInfo.placeholder.remove();
            draggedItemInfo.element.classList.remove('dragging');
            
            initializeAppState();
            updateAndRenderAll();
        }

        function handleSegmentDragEnd() {
            if (draggedItemInfo.element) draggedItemInfo.element.classList.remove('dragging');
            if (draggedItemInfo.placeholder && draggedItemInfo.placeholder.parentNode) draggedItemInfo.placeholder.remove();
            draggedItemInfo = { element: null, originalIndex: null, type: null, placeholder: null };
        }

        function handleMarkerMouseDown(e) {
            if (!e.target.classList.contains('gen-marker')) return;
            e.preventDefault();
            const markerElement = e.target;
            draggedMarkerInfo = {
                chartType: markerElement.dataset.chartType, id: parseInt(markerElement.dataset.id),
                element: markerElement, chartGrid: charts[markerElement.dataset.chartType].grid, startY: e.clientY
            };
            markerElement.classList.add('dragging'); document.body.style.cursor = 'ns-resize';
            isMarkerDragging = true; hideChartTooltip();
            document.addEventListener('mousemove', handleMarkerMouseMove); document.addEventListener('mouseup', handleMarkerMouseUp);
        }

        function handleMarkerMouseMove(e) {
            if (!isMarkerDragging || !draggedMarkerInfo.chartGrid) return;
            
            const { chartType, id, chartGrid } = draggedMarkerInfo;
            const isRecall = chartType === 'recall';
            // Corrected targetLen calculation
            const targetLen = isRecall ? activeGeneratedIndices.length : activeReferenceIndices.length;

            if (targetLen === 0) return;

            const rect = chartGrid.getBoundingClientRect();
            const y = e.clientY - rect.top;
            let newYIndex = Math.floor((1 - (y / rect.height)) * targetLen);
            newYIndex = Math.max(0, Math.min(targetLen - 1, newYIndex));

            const markerToUpdate = markerPositions[chartType].find(m => m.id === id);
            const pathToUpdate = actualPathPositions[chartType].find(p => p.x === id);

            if (markerToUpdate && markerToUpdate.currentY !== newYIndex) {
                markerToUpdate.currentY = newYIndex;
                if(pathToUpdate) {
                  pathToUpdate.y = newYIndex;
                }
                
                // Animate the marker's position directly for smooth feedback
                draggedMarkerInfo.element.style.bottom = `calc(${(newYIndex + 0.5)} * 100% / ${targetLen} - 6px)`;

                // Show preview during drag without full re-render
                const tempMarkers = JSON.parse(JSON.stringify(markerPositions));
                const tempPaths = JSON.parse(JSON.stringify(actualPathPositions));
                showScorePreview(tempMarkers, tempPaths);
            }
        }


        function handleMarkerMouseUp() {
            if (!isMarkerDragging) return;

            if (draggedMarkerInfo.element) draggedMarkerInfo.element.classList.remove('dragging');
            document.body.style.cursor = 'default';
            isMarkerDragging = false; 
            hideScorePreview();
            
            document.removeEventListener('mousemove', handleMarkerMouseMove); 
            document.removeEventListener('mouseup', handleMarkerMouseUp);
            
            // Final update after dragging is complete
            updateAndRenderAll();
        }

        function toggleChunkActiveState(type, originalIndex) {
            let activeIndicesArray = (type === 'reference') ? activeReferenceIndices : activeGeneratedIndices;
            const minChunks = 1;
            const currentIndexPositionInActive = activeIndicesArray.indexOf(originalIndex);
            
            if (currentIndexPositionInActive > -1) { 
                if (activeIndicesArray.length > minChunks) { 
                    activeIndicesArray.splice(currentIndexPositionInActive, 1); 
                } else { 
                    return; // Don't allow deactivating the last chunk
                } 
            } else { 
                activeIndicesArray.push(originalIndex);
                 // When adding a chunk back, we need to decide where it goes.
                 // For simplicity, let's sort the active indices to maintain a somewhat logical order.
                 // A more advanced implementation could insert it at its original position.
                 if(type === 'reference') {
                    activeReferenceIndices.sort((a,b) => a - b);
                 } else {
                    activeGeneratedIndices.sort((a,b) => a - b);
                 }
            }
            
            initializeAppState(); 
            updateAndRenderAll();
        }

        function resetSegmentOrder(type) {
            const currentActiveRefs = new Set(activeReferenceIndices);
            const currentActiveGens = new Set(activeGeneratedIndices);

            if (type === 'generated') {
                 activeGeneratedIndices = Array.from({length: masterGeneratedChunks.length}, (_, i) => i).filter(i => currentActiveGens.has(i));
            } else {
                 activeReferenceIndices = Array.from({length: masterReferenceChunks.length}, (_, i) => i).filter(i => currentActiveRefs.has(i));
            }
            initializeAppState();
            updateAndRenderAll();
        }

        function initializeAppState() {
            const newMarkerPositions = { precision: [], recall: [] };
            const newActualPathPositions = { precision: [], recall: [] };
            
            ['precision', 'recall'].forEach(chartType => {
                const isRecall = chartType === 'recall';
                const sourceLen = isRecall ? activeReferenceIndices.length : activeGeneratedIndices.length;
                const targetLen = isRecall ? activeGeneratedIndices.length : activeReferenceIndices.length;

                if (sourceLen > 0 && targetLen > 0) {
                    const simMatrix = buildCurrentSimilarityMatrix(isRecall);
                    const mappingWindows = get_mapping_windows_generic(sourceLen, targetLen);

                    // Initialize markers for NAS-D
                    const currentMarkers = [];
                    for (let i = 0; i < sourceLen; i++) {
                        const similarityColumn = simMatrix[i];
                        const bestMatchIdx = findBestMatchIndex(similarityColumn);
                        currentMarkers.push({ id: i, currentY: bestMatchIdx });
                    }
                    newMarkerPositions[chartType] = currentMarkers;

                    // Initialize paths for NAS-L
                    newActualPathPositions[chartType] = initializeActualPath(simMatrix, mappingWindows, sourceLen, targetLen);
                }
            });

            // Atomically update the global state
            markerPositions = newMarkerPositions;
            actualPathPositions = newActualPathPositions;

            // Update LCT slider max value based on the smaller of the two target lengths
            const maxPrecisionTargetLen = activeReferenceIndices.length;
            const maxRecallTargetLen = activeGeneratedIndices.length;
            lctSlider.max = Math.max(0, Math.min(maxPrecisionTargetLen, maxRecallTargetLen) - 1);
            if (parseInt(lctSlider.value) > parseInt(lctSlider.max)) {
                lctSlider.value = lctSlider.max;
            }
        }

        function updateLctDescription() {
            const lctValue = parseInt(lctSlider.value);
            const descriptions = [
                "Strict: Only monotonic alignments contribute to calculations",
                "Slight: Small deviations allowed in both distance and flow",
                "Balanced: Moderate jumps forgiven in calculations",
                "Generous: Significant reorderings treated as valid",
                "Very Generous: Large jumps accommodated",
                "Maximum: Most non-monotonic jumps treated as valid"
            ];
            lctDescription.innerHTML = `<strong>${descriptions[Math.min(lctValue, 5)]}</strong>`;
        }

        /**
         * [MODIFIED] This function now shows both NAS-D and NAS-L details.
         */
        function updateChartTooltip(e, chartType, markerId) {
            const highlightedItems = document.querySelectorAll('.segment-list li.highlight');
            highlightedItems.forEach(item => item.classList.remove('highlight'));
            
            chartTooltip.classList.add('visible');
            chartTooltip.style.left = `${e.clientX + 15}px`;
            chartTooltip.style.top = `${e.clientY + 15}px`;
            
            const isRecall = chartType === 'recall';
            const sourceLen = isRecall ? activeReferenceIndices.length : activeGeneratedIndices.length;
            const targetLen = isRecall ? activeGeneratedIndices.length : activeReferenceIndices.length;
            
            const marker = markerPositions[chartType].find(m => m.id === markerId);
            if (!marker) return;

            // Highlight corresponding list items
            const xOriginalIndex = (isRecall ? activeReferenceIndices : activeGeneratedIndices)[marker.id];
            const yOriginalIndex = (isRecall ? activeGeneratedIndices : activeReferenceIndices)[marker.currentY];
            const refLi = document.querySelector(`#referenceSegmentsUl li[data-original-index='${isRecall ? xOriginalIndex : yOriginalIndex}']`);
            const genLi = document.querySelector(`#generatedSegmentsUl li[data-original-index='${isRecall ? yOriginalIndex : xOriginalIndex}']`);
            if(refLi) refLi.classList.add('highlight');
            if(genLi) genLi.classList.add('highlight');
            
            const mappingText = `${isRecall ? 'Ref' : 'Gen'} Chunk ${xOriginalIndex} ↔ ${isRecall ? 'Gen' : 'Ref'} Chunk ${yOriginalIndex}`;
            
            // --- NAS-D Details ---
            let penaltyText = '';
            let finalStatusClass = 'standard';
            const idealWindows = get_mapping_windows_generic(sourceLen, targetLen);
            const window = idealWindows[markerId];
            if (window) {
                const markerY = marker.currentY;
                const windowStart = window.start;
                const windowEnd = window.end - 1;
                const lctAdjustedStart = Math.max(0, windowStart - currentLct);
                const lctAdjustedEnd = Math.min(targetLen - 1, windowEnd + currentLct);
                let penalty = 0;
                if (markerY < lctAdjustedStart) { penalty = lctAdjustedStart - markerY; }
                else if (markerY > lctAdjustedEnd) { penalty = markerY - lctAdjustedEnd; }
                
                if (penalty > 0) {
                    penaltyText = `<strong class="text-red-400">Penalty: ${penalty}</strong>`;
                    finalStatusClass = 'invalid';
                } else {
                    penaltyText = `<strong class="text-green-400">In Window</strong>`;
                }
            }
            
            // --- NAS-L Segment Details ---
            let segmentText = 'End of path';
            const segments = actualPathSegments[chartType] || [];
            const segment = segments.find(s => s.start.x === markerId);
            if (segment) {
                const status = segment.calculation_method;
                const statusColor = status === 'standard' ? 'text-green-400' : status === 'lct-capped' ? 'text-yellow-400' : 'text-red-400';
                segmentText = `<strong class="${statusColor} capitalize">${status}</strong><br>|Δy|: ${Math.abs(segment.dy).toFixed(1)}, Len: ${segment.length.toFixed(2)}`;
                 // If the segment is invalid, it overrides the tooltip color
                 if (status === 'invalid' || status === 'lct-capped' && finalStatusClass === 'standard') {
                     finalStatusClass = status;
                 }
            }

            chartTooltip.className = `visible ${finalStatusClass}`;
            chartTooltip.innerHTML = `
                <div>${mappingText}</div>
                <hr class="my-1 border-slate-500">
                <div><strong>Distance (NAS-D):</strong> ${penaltyText}</div>
                <div><strong>Flow (NAS-L):</strong> ${segmentText}</div>
            `;
        }


        function hideChartTooltip() {
            chartTooltip.classList.remove('visible', 'standard', 'invalid', 'lct-capped');
            const highlightedItems = document.querySelectorAll('.segment-list li.highlight');
            highlightedItems.forEach(item => item.classList.remove('highlight'));
        }

        function animateNumber(el, start, end, duration = 400) {
            if (Math.abs(end - start) < 0.001) { 
                el.textContent = end.toFixed(3); 
                return; 
            }
            const frame = (ct) => {
                const elapsed = ct - st;
                const rawProgress = Math.min(elapsed / duration, 1);
                const progress = easeOutCubic(rawProgress);
                const current = start + (end - start) * progress;
                el.textContent = current.toFixed(3);
                if (rawProgress < 1) requestAnimationFrame(frame);
            };
            const st = performance.now();
            requestAnimationFrame(frame);
        }

        function updateAndRenderAll() {
            currentLct = parseInt(lctSlider.value); lctValueDisplay.textContent = currentLct;
            updateLctDescription();
            
            const numActiveRef = activeReferenceIndices.length;
            const numActiveGen = activeGeneratedIndices.length;

            // --- Precision Calculations ---
            const precNasDResults = calculatePenaltiesAndNAS('precision');
            const nasDPrecision = precNasDResults.nas;

            const precSourceLenL = activeGeneratedIndices.length;
            const precTargetLenL = activeReferenceIndices.length;
            const precMappingWindows = get_mapping_windows_generic(precSourceLenL, precTargetLenL);
            const precIdealBand = computeIdealNarrativeLineBandJS(precMappingWindows, precSourceLenL, precTargetLenL);
            const precPathInfo = computeActualLineLengthJS(actualPathPositions.precision, precTargetLenL, precSourceLenL, currentLct, precIdealBand.floor_path_dy_map);
            actualPathSegments.precision = precPathInfo.segments; // **ADDED** Store segments
            const precNasL = calculateLineNAS(precIdealBand.shortest_line, precIdealBand.longest_line, precPathInfo.totalLength);
            
            // --- Recall Calculations ---
            const recallNasDResults = calculatePenaltiesAndNAS('recall');
            const nasDRecall = recallNasDResults.nas;
            
            const recallSourceLenL = activeReferenceIndices.length;
            const recallTargetLenL = activeGeneratedIndices.length;
            const recallMappingWindows = get_mapping_windows_generic(recallSourceLenL, recallTargetLenL);
            const recallIdealBand = computeIdealNarrativeLineBandJS(recallMappingWindows, recallSourceLenL, recallTargetLenL);
            const recallPathInfo = computeActualLineLengthJS(actualPathPositions.recall, recallTargetLenL, recallSourceLenL, currentLct, recallIdealBand.floor_path_dy_map);
            actualPathSegments.recall = recallPathInfo.segments; // **ADDED** Store segments
            const recallNasL = calculateLineNAS(recallIdealBand.shortest_line, recallIdealBand.longest_line, recallPathInfo.totalLength);

            // --- Combined & Final Calculations ---
            const nasDf1 = _calculate_f1(nasDPrecision, nasDRecall);
            const nasLf1 = _calculate_f1(precNasL, recallNasL);
            const combinedF1NAS = _calculate_f1(nasDf1, nasLf1);
            const regResults = calculateWindowRegularizer(numActiveRef, numActiveGen);
            const windowRegularizer = regResults.windowRegularizer;
            const finalNAS = regularizeNAS(combinedF1NAS, windowRegularizer);

            // --- Update UI ---
            renderSegmentLists();
            
            const precisionResults = {
                nasD: precNasDResults,
                nasL: { idealBand: precIdealBand, actualLength: precPathInfo.totalLength, score: precNasL }
            };
            const recallResults = {
                nasD: recallNasDResults,
                nasL: { idealBand: recallIdealBand, actualLength: recallPathInfo.totalLength, score: recallNasL }
            };
            
            requestAnimationFrame(() => {
                renderChart('precision', precisionResults);
                renderChart('recall', recallResults);
            });
            
            // Update chart metrics
            animateNumber(document.getElementById('precisionNasD'), parseFloat(document.getElementById('precisionNasD').textContent)||0, nasDPrecision);
            animateNumber(document.getElementById('precisionNasL'), parseFloat(document.getElementById('precisionNasL').textContent)||0, precNasL);
            animateNumber(document.getElementById('precisionCombined'), parseFloat(document.getElementById('precisionCombined').textContent)||0, _calculate_f1(nasDPrecision, precNasL));
            
            animateNumber(document.getElementById('recallNasD'), parseFloat(document.getElementById('recallNasD').textContent)||0, nasDRecall);
            animateNumber(document.getElementById('recallNasL'), parseFloat(document.getElementById('recallNasL').textContent)||0, recallNasL);
            animateNumber(document.getElementById('recallCombined'), parseFloat(document.getElementById('recallCombined').textContent)||0, _calculate_f1(nasDRecall, recallNasL));

            // Update overall metrics
            animateNumber(document.getElementById('overallNasDF1'), parseFloat(document.getElementById('overallNasDF1').textContent)||0, nasDf1);
            animateNumber(document.getElementById('overallNasLF1'), parseFloat(document.getElementById('overallNasLF1').textContent)||0, nasLf1);
            animateNumber(document.getElementById('combinedF1NAS'), parseFloat(document.getElementById('combinedF1NAS').textContent)||0, combinedF1NAS);
            animateNumber(document.getElementById('windowRegularizer'), parseFloat(document.getElementById('windowRegularizer').textContent)||0, windowRegularizer);
            animateNumber(document.getElementById('finalCompleteNas'), parseFloat(document.getElementById('finalCompleteNas').textContent)||0, finalNAS);
            
            updateDynamicBackground(finalNAS);
        }
        
        // --- INITIALIZATION ---
        window.addEventListener('load', () => {
            activeReferenceIndices = Array.from({ length: masterReferenceChunks.length }, (_, i) => i);
            activeGeneratedIndices = Array.from({ length: masterGeneratedChunks.length }, (_, i) => i);
            
            document.getElementById('start-tour-btn').addEventListener('click', () => tourManager.start());
            
            lctSlider.addEventListener('input', () => {
              // Only trigger a full re-render on slider input, not every frame of dragging
              if (!isMarkerDragging) {
                updateAndRenderAll();
              }
            });

            resetGenOrderBtn.addEventListener('click', () => resetSegmentOrder('generated'));
            resetRefOrderBtn.addEventListener('click', () => resetSegmentOrder('reference'));
            [generatedSegmentsUl, referenceSegmentsUl].forEach(ul => {
                ul.addEventListener('dragstart', handleSegmentDragStart);
                ul.addEventListener('dragover', handleSegmentDragOver);
                ul.addEventListener('drop', handleSegmentDrop);
                ul.addEventListener('dragend', handleSegmentDragEnd);
            });
            document.addEventListener('mousedown', handleMarkerMouseDown);
            
            // Tooltip events
            ['precisionMarkerContainer', 'recallMarkerContainer'].forEach(id => {
                document.getElementById(id).addEventListener('mouseover', e => {
                    if (e.target.classList.contains('gen-marker') && !isMarkerDragging) {
                        updateChartTooltip(e, e.target.dataset.chartType, parseInt(e.target.dataset.id));
                    }
                });
                document.getElementById(id).addEventListener('mouseout', e => {
                    if (e.target.classList.contains('gen-marker') && !isMarkerDragging) {
                        hideChartTooltip();
                    }
                });
            });
            
            let resizeTimer;
            window.addEventListener('resize', () => { clearTimeout(resizeTimer); resizeTimer = setTimeout(updateAndRenderAll, 150); });
            
            initializeAppState();
            updateAndRenderAll();
        });
    </script>
</body>
</html>
