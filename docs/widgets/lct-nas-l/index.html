<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Effect of LCT on Line-based NAS (NAS-L)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        
        /* --- Base Styles --- */
        html { scroll-behavior: smooth; }
        body { font-family: 'Inter', sans-serif; transition: background 1.5s cubic-bezier(0.25, 0.1, 0.25, 1); }
        :root { --ease-out-quad: cubic-bezier(0.25, 0.46, 0.45, 0.94); --ease-out-cubic: cubic-bezier(0.215, 0.610, 0.355, 1.000); }

        /* --- Glassmorphism Card Style --- */
        .interactive-card {
            background: rgba(255, 255, 255, 0.5); backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: transform 0.35s var(--ease-out-cubic), box-shadow 0.35s var(--ease-out-cubic), border-color 0.35s var(--ease-out-cubic);
            will-change: transform, box-shadow;
        }
        .interactive-card:hover { box-shadow: 0 12px 30px -8px rgba(0, 0, 0, 0.12), 0 8px 15px -8px rgba(0, 0, 0, 0.1); transform: translateY(-5px); border-color: rgba(255, 255, 255, 0.5); }
        
        /* --- Card Color Themes --- */
        .intro-card { background: linear-gradient(135deg, rgba(254, 252, 232, 0.6) 0%, rgba(254, 243, 199, 0.5) 100%); border-color: rgba(251, 191, 36, 0.5); }
        .demo-card { background: linear-gradient(135deg, rgba(255, 255, 255, 0.6) 0%, rgba(248, 250, 252, 0.5) 100%); border-color: rgba(226, 232, 240, 0.7); }
        .metrics-card { background: linear-gradient(135deg, rgba(240, 249, 255, 0.6) 0%, rgba(219, 234, 254, 0.5) 100%); border-color: rgba(147, 197, 253, 0.6); }
        .formula-card { background: linear-gradient(135deg, rgba(237, 233, 254, 0.6) 0%, rgba(221, 214, 254, 0.5) 100%); border-color: rgba(196, 181, 253, 0.6); }

        /* --- Tooltip & Tour Styles --- */
        #chartTooltip { position: fixed; background: rgba(45, 55, 72, 0.9); backdrop-filter: blur(5px); color: white; padding: 8px 12px; border-radius: 6px; font-size: 0.8rem; z-index: 100; pointer-events: none; opacity: 0; transition: opacity 0.25s, transform 0.25s; transform: scale(0.95); }
        #chartTooltip.visible { opacity: 1; transform: scale(1); }
        #chartTooltip.standard { border-left: 4px solid #22c55e; }
        #chartTooltip.lct-capped { border-left: 4px solid #f59e0b; }
        #chartTooltip.invalid { border-left: 4px solid #ef4444; }
        #tour-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 9998; opacity: 0; transition: opacity 0.4s ease-in-out; pointer-events: none; }
        .tour-highlight { position: relative; z-index: 9999; box-shadow: 0 0 0 9999px rgba(0,0,0,0.6), 0 0 20px rgba(255, 255, 255, 0.9); border-radius: 0.5rem; transition: box-shadow 0.4s ease-in-out; }
        #tour-callout { position: absolute; background: white; color: #334155; padding: 1rem; border-radius: 0.5rem; box-shadow: 0 5px 15px rgba(0,0,0,0.2); z-index: 10000; max-width: 300px; border-left: 4px solid #3b82f6; transition: opacity 0.3s, transform 0.3s; transform: translateY(10px); opacity: 0; }
        #tour-callout.visible { transform: translateY(0); opacity: 1; }
        #tour-callout button { background-color: #3b82f6; color: white; padding: 0.5rem 1rem; border: none; border-radius: 0.375rem; cursor: pointer; transition: background-color 0.2s, transform 0.2s; }
        #tour-callout button:hover { background-color: #2563eb; transform: translateY(-1px); }

        /* --- Chart & UI Element Styles --- */
        .axis-label { position: absolute; font-size: 0.75rem; color: #475569; font-weight: 500; white-space: nowrap; z-index: 6; }
        .ideal-mapping-window { position: absolute; border: 2px solid #0d9488; background-color: rgba(20, 184, 166, 0.1); box-sizing: border-box; z-index: 1; transition: all 0.3s; pointer-events: none; border-radius: 0.25rem; }
        .chart-grid-background { background-image: linear-gradient(to right, #e2e8f0 1px, transparent 1px), linear-gradient(to bottom, #e2e8f0 1px, transparent 1px); }
        .gen-marker { position: absolute; width: 12px; height: 12px; border-radius: 50%; background-color: #8b5cf6; border: 2px solid white; cursor: grab; box-shadow: 0 2px 4px rgba(0,0,0,0.3); z-index: 10; transition: all 0.25s; will-change: transform, left, bottom; }
        .gen-marker:hover { transform: scale(1.4); }
        .gen-marker.dragging { background-color: #a78bfa; box-shadow: 0 4px 8px rgba(0,0,0,0.4); transform: scale(1.5); cursor: grabbing; }
        .grid-cell-overlay { position: absolute; z-index: 5; transition: background-color 0.2s; }
        .grid-cell-overlay.drag-over { background-color: rgba(139, 92, 246, 0.1); border: 1px dashed #8b5cf6; z-index: 7; border-radius: 4px; }
        .preset-btn { transition: all 0.2s; background: linear-gradient(135deg, #0d9488 0%, #14b8a6 100%); }
        .preset-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(13, 148, 136, 0.3); }
        .step-number { background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%); color: white; width: 2rem; height: 2rem; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 0.875rem; flex-shrink: 0; }
        details summary { cursor: pointer; user-select: none; transition: color 0.2s; }
        details summary:hover { color: #1d4ed8; }
        details summary::-webkit-details-marker { display: none; }
        details summary .summary-icon { display: inline-block; margin-right: 0.5rem; transition: transform 0.25s; }
        details[open] summary .summary-icon { transform: rotate(90deg); }

        /* --- Path & Segment Styles --- */
        #idealPathsSvg, #actualPathSvg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 2; }
        .floor-path-line { stroke: #0ea5e9; stroke-width: 2.5px; fill: none; transition: d 0.5s var(--ease-out-cubic); }
        .ceil-path-line { stroke: #ec4899; stroke-width: 2.5px; fill: none; transition: d 0.5s var(--ease-out-cubic); }
        .actual-path-line { stroke: #8b5cf6; stroke-width: 3px; fill: none; }
        .path-marker-circle { r: 4px; stroke-width: 2px; }
        .lct-guidance-line-base { stroke: rgba(34, 197, 94, 0.7); stroke-width: 1.5px; stroke-dasharray: 4 3; }
        .lct-guidance-line-expanded { stroke: rgba(245, 158, 11, 0.7); stroke-width: 1.5px; stroke-dasharray: 2 4; }
        .path-segment-standard { stroke: #059669; stroke-width: 4px; transition: all 0.3s ease; }
        .path-segment-lct-capped { stroke: #d97706; stroke-width: 4px; transition: all 0.3s ease; }
        .path-segment-invalid { stroke: #dc2626; stroke-width: 4px; stroke-dasharray: 6 3; transition: all 0.3s ease; }

        /* --- Modern Hover Cone Styles --- */
        .hover-cone-standard {
            fill: rgba(34, 197, 94, 0.15);
            stroke: rgba(34, 197, 94, 0.4);
            stroke-width: 1.5;
            filter: drop-shadow(0 4px 12px rgba(34, 197, 94, 0.25)) drop-shadow(0 2px 6px rgba(34, 197, 94, 0.15));
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        
        .hover-cone-lct-capped {
            fill: rgba(245, 158, 11, 0.12);
            stroke: rgba(245, 158, 11, 0.35);
            stroke-width: 1.5;
            filter: drop-shadow(0 4px 12px rgba(245, 158, 11, 0.22)) drop-shadow(0 2px 6px rgba(245, 158, 11, 0.12));
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        /* --- Segment Info Labels --- */
        .segment-info-label {
            position: absolute; top: 16px; left: 50%; transform: translateX(-50%);
            font-size: 0.65rem; font-weight: 600; background-color: rgba(255, 255, 255, 0.95);
            padding: 2px 6px; border-radius: 4px; z-index: 15; text-align: center;
            border: 1px solid #e2e8f0; min-width: 60px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            transition: opacity 0.25s var(--ease-out-quad), transform 0.25s var(--ease-out-quad);
        }
        .segment-info-label.standard { color: #059669; border-color: #34d399; background-color: rgba(52, 211, 153, 0.1); }
        .segment-info-label.lct-capped { color: #d97706; border-color: #fbbf24; background-color: rgba(251, 191, 36, 0.1); }
        .segment-info-label.invalid { color: #dc2626; border-color: #f87171; background-color: rgba(248, 113, 113, 0.1); }

        /* --- LCT Explorer Styles --- */
        .lct-explorer-wrapper { background: rgba(255, 255, 255, 0.7); border-radius: 0.75rem; border: 1px solid rgba(0,0,0,0.05); padding: 1rem; }
        .lct-explorer-container { display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; align-items: center; }
        .lct-anim-grid-wrapper { text-align: center; }
        .lct-anim-grid { display: grid; position: relative; background-color: #f8fafc; border: 1px solid #e2e8f0; border-radius: 0.5rem; margin: 0 auto; }
        .lct-static-cell { display: flex; align-items: center; justify-content: center; font-weight: 500; font-size: 0.7rem; line-height: 1; color: #475569; background-color: #f1f5f9; border-radius: 0.25rem; transition: background-color 0.4s ease; padding: 4px; }
        .lct-static-cell.highlight { background-color: rgba(253, 224, 71, 0.35); }
        .lct-moving-marker { position: absolute; z-index: 10; display: flex; align-items: center; justify-content: center; transition: all 0.8s cubic-bezier(0.68, -0.55, 0.27, 1.55); }
        .lct-marker-dot { width: 14px; height: 14px; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.2); transition: background-color 0.4s ease; }
        .lct-marker-label { position: absolute; top: 20px; font-size: 0.7rem; font-weight: 600; padding: 2px 6px; border-radius: 4px; background: rgba(255,255,255,0.9); border: 1px solid #e2e8f0; white-space: nowrap; transition: opacity 0.4s, color 0.4s, border-color 0.4s; }
        /* Marker Status Styles */
        .lct-marker-dot.status-in-window { background-color: #22c55e; }
        .lct-marker-label.status-in-window { color: #166534; border-color: #86efac; }
        .lct-marker-dot.status-penalty { background-color: #ef4444; }
        .lct-marker-label.status-penalty { color: #991b1b; border-color: #fca5a5; }
        .lct-marker-dot.status-forgiven { background-color: #3b82f6; }
        .lct-marker-label.status-forgiven { color: #1e40af; border-color: #93c5fd; }
        .ghost-score { color: #9ca3af; }
    </style>
</head>
<body class="h-full text-slate-700 antialiased">
    <div id="app-background" class="fixed inset-0 z-[-1] transition-all duration-1000"></div>
    <div id="tour-overlay"></div>
    <div id="chartTooltip"></div>

    <main class="w-full max-w-8xl mx-auto p-4 sm:p-6 lg:p-8 min-h-screen">
        
        <!-- Header -->
        <div class="text-center mb-8 relative">
            <div class="flex items-center justify-center mb-4">
                <div class="bg-purple-100 text-purple-800 px-3 py-1 rounded-full text-xs font-semibold uppercase tracking-wide">LCT Analysis</div>
            </div>
            <h1 class="text-3xl sm:text-4xl font-bold bg-gradient-to-r from-teal-600 to-teal-800 bg-clip-text text-transparent">The Effect of LCT on NAS-L</h1>
            <p class="mt-3 text-lg text-slate-600 max-w-4xl mx-auto">Explore how Local Chronology Threshold (LCT) affects path segment classification and calculability in line-based narrative flow assessment.</p>
            <button id="start-tour-btn" class="absolute top-0 right-0 bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-full transition-transform transform hover:scale-105">
                <i class="fas fa-magic mr-2"></i>Start Tour
            </button>
        </div>

        <!-- Introduction Section -->
        <div class="mb-8">
            <div id="tour-step-1" class="intro-card interactive-card rounded-xl p-6">
                <div class="flex items-center mb-4"><i class="fas fa-route text-amber-600 text-xl mr-3"></i><h2 class="text-xl font-semibold text-amber-800">Introduction to LCT Effect on NAS-L</h2></div>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
                    <div class="bg-white bg-opacity-60 p-4 rounded-lg"><h3 class="font-semibold text-amber-700 mb-2 flex items-center"><i class="fas fa-question-circle text-amber-500 mr-2"></i>What is NAS-L?</h3><p class="text-sm text-slate-700">NAS-L evaluates narrative flow by computing path segments between chunks. Unlike NAS-D which penalizes distance, NAS-L measures segment calculability and path dynamics.</p></div>
                    <div class="bg-white bg-opacity-60 p-4 rounded-lg"><h3 class="font-semibold text-amber-700 mb-2 flex items-center"><i class="fas fa-exclamation-triangle text-amber-500 mr-2"></i>Why LCT for Lines?</h3><p class="text-sm text-slate-700">LCT determines which path segments are calculable. Segments within tolerance remain standard, those beyond base threshold become LCT-capped, and extreme deviations become invalid.</p></div>
                    <div class="bg-white bg-opacity-60 p-4 rounded-lg"><h3 class="font-semibold text-amber-700 mb-2 flex items-center"><i class="fas fa-cogs text-amber-500 mr-2"></i>Segment Types</h3><p class="text-sm text-slate-700">Standard (green): Full calculation. LCT-Capped (orange): Uses floor path dynamics. Invalid (red): Non-calculable, contributes 0 to total path length.</p></div>
                </div>
                <details id="tour-step-2" class="mb-4" open>
                    <summary class="font-semibold text-amber-700 mb-3 flex items-center"><i class="fas fa-chevron-right summary-icon"></i>LCT Neighborhood Explorer</summary>
                    <div class="mt-4 space-y-8 ml-6 border-l-2 border-slate-200 pl-6">
                        
                        <div class="flex items-start">
                            <div class="step-number mr-4">1</div>
                            <div class="flex-1">
                                <h4 class="font-semibold text-slate-800 mb-2">LCT 1: 2×2 Neighborhood Forgiveness</h4>
                                <p class="text-sm text-slate-600 mb-3">Compare how swapping two adjacent sentence fragments affects segment calculability with and without LCT.</p>
                                <div id="lct1-explorer" class="lct-explorer-wrapper"></div>
                            </div>
                        </div>

                        <div class="flex items-start">
                            <div class="step-number mr-4">2</div>
                            <div class="flex-1">
                                <h4 class="font-semibold text-slate-800 mb-2">LCT 2: 3×3 Neighborhood Forgiveness</h4>
                                <p class="text-sm text-slate-600 mb-3">In a larger neighborhood, more complex reorderings become calculable. Notice how LCT enables segment calculation.</p>
                                 <div id="lct2-explorer" class="lct-explorer-wrapper"></div>
                            </div>
                        </div>
                    </div>
                </details>
            </div>
        </div>

        <!-- Main Content Layout -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <div class="lg:col-span-2 space-y-8">
                <!-- Chart -->
                <div class="demo-card interactive-card rounded-xl p-4">
                    <div class="text-center mb-4">
                        <h2 class="text-lg font-bold text-slate-800">LCT Effect on Path Segment Classification</h2>
                    </div>
                    
                    <div class="relative w-full max-w-2xl mx-auto pt-4 pb-36 pl-20 pr-4">
                        <div class="absolute top-1/2 -left-12 -translate-y-16 -rotate-90 font-semibold text-sm text-slate-600 whitespace-nowrap">Reference Chunks</div>
                        <div class="absolute bottom-20 left-1/2 -translate-x-1/2 font-semibold text-sm text-slate-600">Generated Chunks</div>
                        <div class="relative w-full aspect-square">
                            <div id="chartGrid" class="absolute inset-0 bg-white rounded-lg chart-grid-background border border-slate-200">
                                <svg id="idealPathsSvg"></svg>
                                <svg id="actualPathSvg"></svg>
                                <div id="idealMappingContainer"></div>
                                <div id="dropTargetCellContainer"></div>
                                <div id="genChunkMarkerContainer"></div>
                                <div id="axisLabelContainerY"></div>
                                <div id="axisLabelContainerX"></div>
                            </div>
                        </div>
                        <div class="absolute -bottom-0 left-0 right-0 grid grid-cols-3 gap-x-4 gap-y-1 text-center text-xs text-slate-600 bg-white/80 p-2 rounded-md">
                            <div><span>LCT Window Base:</span><br><span id="lctWindowBaseDisplay" class="font-bold text-green-600">0</span></div>
                            <div><span>Expanded Window:</span><br><span id="expandedWindowDisplay" class="font-bold text-orange-600">0</span></div>
                            <div><span>Calculable Segments:</span><br><span id="calculableSegmentsDisplay" class="font-bold text-blue-600">0/0</span></div>
                        </div>
                    </div>
                </div>

                <div class="demo-card interactive-card rounded-xl p-6">
                    <h3 class="font-semibold text-slate-800 mb-3 flex items-center text-lg"><i class="fas fa-search-plus text-teal-600 mr-2"></i>Explore Advanced Interactions</h3>
                    <div class="mt-2 space-y-4 text-sm text-slate-700 bg-slate-50/50 p-4 rounded-lg border border-slate-200">
                        <p class="flex items-start"><strong class="mr-3 text-teal-600 text-base mt-0.5">▶</strong> <span><strong>Segment Classification:</strong> Drag markers and watch how path segments change color from green (standard) to orange (LCT-capped) to red (invalid).</span></p>
                        <p class="flex items-start"><strong class="mr-3 text-teal-600 text-base mt-0.5">▶</strong> <span><strong>LCT Tolerance:</strong> Increase the LCT slider to see how invalid segments become LCT-capped, affecting total path length calculation.</span></p>
                        <p class="flex items-start"><strong class="mr-3 text-teal-600 text-base mt-0.5">▶</strong> <span><strong>Path Length Impact:</strong> Notice how calculable segments contribute to the total actual path length, while invalid segments contribute zero.</span></p>
                    </div>
                </div>
            </div>

            <!-- Controls Sidebar -->
            <div class="lg:col-span-1">
                <div class="sticky top-6 space-y-6">
                    
                    <div id="tour-step-3" class="metrics-card interactive-card rounded-xl p-6">
                        <h3 class="text-lg font-semibold text-blue-800 mb-4 flex items-center">
                            <i class="fas fa-calculator text-blue-600 mr-2"></i>Live NAS-L Metrics
                        </h3>
                        <div class="space-y-3">
                            <details class="text-center bg-blue-50/70 p-3 rounded-lg border border-blue-200 cursor-pointer">
                                <summary class="list-none">
                                    <label class="block text-sm font-medium text-blue-700 mb-1 cursor-pointer">Line NAS-L Score</label>
                                    <span id="nasLScoreDisplay" class="text-4xl font-bold text-blue-600">-</span>
                                    <span id="nasLScorePreview" class="text-4xl font-bold ghost-score"></span>
                                    <p class="text-xs text-slate-500 mt-1">Click to see calculation</p>
                                </summary>
                                <div class="text-xs text-slate-600 mt-3 pt-2 border-t border-blue-200">
                                    Flow assessment based on path length ratios
                                </div>
                            </details>
                            <div class="grid grid-cols-2 gap-4">
                                <div class="text-center">
                                    <label class="block text-sm font-medium text-blue-700 mb-1">Floor Length</label>
                                    <span id="floorLengthDisplay" class="text-2xl font-bold text-green-600">-</span>
                                </div>
                                <div class="text-center">
                                    <label class="block text-sm font-medium text-blue-700 mb-1">Ceil Length</label>
                                    <span id="ceilLengthDisplay" class="text-2xl font-bold text-pink-600">-</span>
                                </div>
                            </div>
                            <div class="text-center">
                                <label class="block text-sm font-medium text-blue-700 mb-1">Actual Length</label>
                                <span id="actualLengthDisplay" class="text-xl font-bold text-purple-600">-</span>
                                <span id="actualLengthPreview" class="text-xl font-bold ghost-score"></span>
                            </div>
                        </div>
                    </div>
                    
                    <div id="tour-step-4" class="formula-card interactive-card rounded-xl p-6">
                        <h3 class="text-lg font-semibold text-purple-800 mb-4 flex items-center">
                            <i class="fas fa-sliders-h text-purple-600 mr-2"></i>LCT Parameter
                        </h3>
                        <div class="space-y-4">
                            <div class="flex items-center justify-between">
                                <label for="lctSlider" class="text-sm font-medium text-purple-700">LCT Multiplier (τ<sub>LCT</sub>):</label>
                                <span id="lctValueDisplay" class="text-lg font-bold text-purple-600 bg-purple-100 px-3 py-1 rounded">0</span>
                            </div>
                            <input type="range" id="lctSlider" min="0" max="8" value="0" class="w-full h-2 bg-purple-200 rounded-lg appearance-none cursor-pointer">
                            <div id="lctDescription" class="text-xs text-purple-600"></div>
                        </div>
                    </div>

                    <div id="tour-step-5" class="demo-card interactive-card rounded-xl p-6">
                        <h3 class="text-lg font-semibold text-slate-800 mb-4 flex items-center">
                            <i class="fas fa-th text-teal-600 mr-2"></i>Grid Configuration
                        </h3>
                        <div class="space-y-4">
                            <div class="flex items-center justify-between">
                                <label for="refLenInput" class="text-sm font-medium text-slate-700">Reference Chunks (Y):</label>
                                <input type="number" id="refLenInput" min="1" max="10" value="10" 
                                       class="w-16 px-2 py-1 border border-slate-300 rounded text-center text-sm focus:ring-2 focus:ring-teal-500 focus:border-teal-500 transition-all">
                            </div>
                            <div class="flex items-center justify-between">
                                <label for="genLenInput" class="text-sm font-medium text-slate-700">Generated Chunks (X):</label>
                                <input type="number" id="genLenInput" min="1" max="10" value="10" 
                                       class="w-16 px-2 py-1 border border-slate-300 rounded text-center text-sm focus:ring-2 focus:ring-teal-500 focus:border-teal-500 transition-all">
                            </div>
                        </div>
                    </div>

                    <div id="tour-step-6" class="demo-card interactive-card rounded-xl p-6">
                        <h3 class="text-lg font-semibold text-slate-800 mb-4 flex items-center">
                            <i class="fas fa-magic text-purple-600 mr-2"></i>Test Scenarios
                        </h3>
                        <div class="grid grid-cols-2 gap-2">
                            <button class="preset-btn text-white px-3 py-2 rounded-lg text-xs font-medium" onclick="animateToScenario('optimal')"><i class="fas fa-check-circle mr-1"></i>Optimal</button>
                            <button class="preset-btn text-white px-3 py-2 rounded-lg text-xs font-medium" onclick="animateToScenario('lct1Rotation')"><i class="fas fa-sync-alt mr-1"></i>2x2 Rotation</button>
                            <button class="preset-btn text-white px-3 py-2 rounded-lg text-xs font-medium" onclick="animateToScenario('lct2Rotation')"><i class="fas fa-th-large mr-1"></i>3x3 Rotation</button>
                            <button class="preset-btn text-white px-3 py-2 rounded-lg text-xs font-medium" onclick="animateToScenario('deleteEnd')"><i class="fas fa-cut mr-1"></i>Delete End</button>
                            <button class="preset-btn text-white px-3 py-2 rounded-lg text-xs font-medium" onclick="animateToScenario('deleteMiddle')"><i class="fas fa-cut mr-1"></i>Delete Middle</button>
                            <button class="preset-btn text-white px-3 py-2 rounded-lg text-xs font-medium" onclick="animateToScenario('deleteBegin')"><i class="fas fa-cut mr-1"></i>Delete Begin</button>
                        </div>
                         <div id="scenarioTip" class="mt-4 bg-slate-50/70 p-3 rounded-lg border border-slate-200 text-xs text-slate-600 transition-all duration-300">
                             <p><strong>Tip:</strong> Click a scenario to see how different alignments affect segment classification and path calculability.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <script>
        // Global state
        let numUnitsY = 10, numUnitsX = 10, currentLct = 0;
        let markers_config = [], currentPrecisionWindows = [], currentFloorPath = [], currentCeilPath = [];
        let currentFloorLength = 0, currentCeilLength = 0, currentActualLength = 0, currentLineNas = 0;
        let floorPathDyMap = {}, currentActualPathSegments = [], currentLctWindowBase = 0, currentExpandedLctWindow = 0;
        let draggedMarkerId = null, animationFrameId = null, isMarkerDragging = false;
        let hoveredMarkerId = null;
        let animatedSegments = []; // Track animated segments for smooth transitions

        // DOM references
        const elements = {
            chartGrid: document.getElementById('chartGrid'),
            idealMappingContainer: document.getElementById('idealMappingContainer'),
            genChunkMarkerContainer: document.getElementById('genChunkMarkerContainer'),
            dropTargetCellContainer: document.getElementById('dropTargetCellContainer'),
            axisLabelContainerX: document.getElementById('axisLabelContainerX'),
            axisLabelContainerY: document.getElementById('axisLabelContainerY'),
            idealPathsSvg: document.getElementById('idealPathsSvg'),
            actualPathSvg: document.getElementById('actualPathSvg'),
            lctSlider: document.getElementById('lctSlider'),
            lctValueDisplay: document.getElementById('lctValueDisplay'),
            lctDescription: document.getElementById('lctDescription'),
            refLenInput: document.getElementById('refLenInput'),
            genLenInput: document.getElementById('genLenInput'),
            floorLengthDisplay: document.getElementById('floorLengthDisplay'),
            ceilLengthDisplay: document.getElementById('ceilLengthDisplay'),
            actualLengthDisplay: document.getElementById('actualLengthDisplay'),
            calculableSegmentsDisplay: document.getElementById('calculableSegmentsDisplay'),
            nasLScoreDisplay: document.getElementById('nasLScoreDisplay'),
            chartTooltip: document.getElementById('chartTooltip'),
            appBackground: document.getElementById('app-background'),
            lctWindowBaseDisplay: document.getElementById('lctWindowBaseDisplay'),
            expandedWindowDisplay: document.getElementById('expandedWindowDisplay'),
            nasLScorePreview: document.getElementById('nasLScorePreview'),
            actualLengthPreview: document.getElementById('actualLengthPreview')
        };

        // Easing functions
        const easeOutCubic = t => 1 - Math.pow(1 - t, 3);

        // Story chunks for LCT explorer
        const storyChunks = [
            "Alice enters wonderland...", "She meets the rabbit...", "Down the rabbit hole...", "The tea party begins...",
            "The queen appears...", "Off with their heads!...", "Alice grows larger...", "The trial starts...",
            "Everything becomes clear...", "Alice wakes up..."
        ];

        // --- TOUR MANAGER ---
        const tourManager = {
            isActive: false, currentStep: 0, overlay: document.getElementById('tour-overlay'),
            steps: [ 
                { selector: '#tour-step-1', text: 'This introduction explains NAS-L and how LCT affects path segment calculability rather than penalties.', position: 'bottom' }, 
                { selector: '#tour-step-2', text: 'This explorer shows how path segments are classified as standard, LCT-capped, or invalid based on displacement.', position: 'bottom' }, 
                { selector: '#tour-step-3', text: 'These metrics show the live NAS-L score calculation based on path length ratios and segment calculability.', position: 'left' }, 
                { selector: '#tour-step-4', text: 'Adjust LCT to see how it affects the window size and segment classification in real-time.', position: 'left' }, 
                { selector: '#tour-step-5', text: 'Change grid dimensions to see how all calculations adapt to different aspect ratios.', position: 'left' },
                { selector: '#tour-step-6', text: 'Try different scenarios to see how misalignments affect segment types and path calculability.', position: 'left' } 
            ],
            start: function() { this.isActive = true; this.currentStep = 0; this.overlay.style.pointerEvents = 'auto'; this.overlay.style.opacity = '1'; this.showStep(); },
            next: function() { this.cleanupCurrentStep(); this.currentStep++; if (this.currentStep < this.steps.length) { setTimeout(() => this.showStep(), 400); } else { this.end(); } },
            showStep: function() { const step = this.steps[this.currentStep]; const targetElement = document.querySelector(step.selector); if (!targetElement) { this.end(); return; } targetElement.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' }); setTimeout(() => { targetElement.classList.add('tour-highlight'); const callout = document.createElement('div'); callout.id = 'tour-callout'; callout.innerHTML = `<p class="text-sm mb-4">${step.text}</p><div class="flex justify-end"><button onclick="tourManager.next()">Next &rarr;</button></div>`; document.body.appendChild(callout); const targetRect = targetElement.getBoundingClientRect(); const calloutRect = callout.getBoundingClientRect(); const margin = 15; const scrollY = window.scrollY || document.documentElement.scrollTop; const scrollX = window.scrollX || document.documentElement.scrollLeft; let top, left; switch (step.position) { case 'bottom': top = targetRect.bottom + scrollY + margin; left = targetRect.left + scrollX + (targetRect.width / 2) - (calloutRect.width / 2); break; case 'top': top = targetRect.top + scrollY - calloutRect.height - margin; left = targetRect.left + scrollX + (targetRect.width / 2) - (calloutRect.width / 2); break; case 'left': top = targetRect.top + scrollY + (targetRect.height / 2) - (calloutRect.height / 2); left = targetRect.left + scrollX - calloutRect.width - margin; break; case 'right': default: top = targetRect.top + scrollY + (targetRect.height / 2) - (calloutRect.height / 2); left = targetRect.right + scrollX + margin; break; } const viewportRight = scrollX + window.innerWidth; const viewportBottom = scrollY + window.innerHeight; if (left < scrollX + margin) left = scrollX + margin; if (left + calloutRect.width > viewportRight - margin) left = viewportRight - calloutRect.width - margin; if (top < scrollY + margin) top = scrollY + margin; if (top + calloutRect.height > viewportBottom - margin) top = viewportBottom - calloutRect.height - margin; callout.style.top = `${top}px`; callout.style.left = `${left}px`; requestAnimationFrame(() => { callout.classList.add('visible'); }); }, 350); },
            cleanupCurrentStep: function() { const oldHighlight = document.querySelector('.tour-highlight'); if (oldHighlight) oldHighlight.classList.remove('tour-highlight'); const oldCallout = document.getElementById('tour-callout'); if (oldCallout) oldCallout.remove(); },
            end: function() { this.cleanupCurrentStep(); this.isActive = false; this.overlay.style.opacity = '0'; setTimeout(() => this.overlay.style.pointerEvents = 'none', 400); }
        };

        // --- LCT EXPLORER ---
        const lctExplorerManager = {
            configs: {
                lct1: { containerId: 'lct1-explorer', size: 2, animation: [ { label: 'Ideal', mapping: { 0: 0, 1: 1 } }, { label: 'Swapped', mapping: { 0: 1, 1: 0 } }, ], textIndices: [2, 3] },
                lct2: { containerId: 'lct2-explorer', size: 3, animation: [ { label: 'Ideal', mapping: { 0: 0, 1: 1, 2: 2 } }, { label: 'Corner Swap', mapping: { 0: 2, 1: 1, 2: 0 } }, { label: 'Rotation', mapping: { 0: 1, 1: 2, 2: 0 } }, ], textIndices: [4, 5, 6] }
            },
            explorers: {}, intervals: {},
            init() { Object.values(this.intervals).forEach(clearInterval); this.initExplorer('lct1'); this.initExplorer('lct2'); },
            initExplorer(type) {
                const config = this.configs[type]; const wrapper = document.getElementById(config.containerId); if (!wrapper) return;
                wrapper.innerHTML = '';
                const scenarioLabel = document.createElement('p'); scenarioLabel.className = 'text-center text-sm font-medium text-slate-600 mb-2'; wrapper.appendChild(scenarioLabel);
                const container = document.createElement('div'); container.className = 'lct-explorer-container'; wrapper.appendChild(container);
                const withoutLCT = this.createGridInstance(config, 'Without LCT');
                const withLCT = this.createGridInstance(config, `With LCT=${config.size-1}`);
                container.appendChild(withoutLCT.wrapper); container.appendChild(withLCT.wrapper);
                this.explorers[type] = { config, scenarioLabel, grids: [withoutLCT, withLCT], caseIndex: 0 };
                this.runAnimation(type); this.intervals[type] = setInterval(() => this.runAnimation(type), 3000);
            },
            createGridInstance(config, title) {
                const wrapper = document.createElement('div'); wrapper.className = 'lct-anim-grid-wrapper';
                const titleEl = document.createElement('h5'); titleEl.className = 'text-sm font-semibold mb-2 text-slate-700'; titleEl.textContent = title; wrapper.appendChild(titleEl);
                const grid = document.createElement('div'); const cellSize = 70; const gap = 4;
                grid.className = 'lct-anim-grid'; grid.style.gridTemplateColumns = `repeat(${config.size}, ${cellSize}px)`; grid.style.gridTemplateRows = `repeat(${config.size}, ${cellSize}px)`;
                grid.style.gap = `${gap}px`; grid.style.width = `${config.size * cellSize + (config.size - 1) * gap}px`; grid.style.height = `${config.size * cellSize + (config.size - 1) * gap}px`;
                wrapper.appendChild(grid);
                const staticCells = [];
                for (let i = 0; i < config.size * config.size; i++) {
                    const cell = document.createElement('div'); cell.className = 'lct-static-cell'; cell.style.width = `${cellSize}px`; cell.style.height = `${cellSize}px`;
                    grid.appendChild(cell); staticCells.push(cell);
                }
                const markers = {};
                for(let i=0; i<config.size; i++) {
                    const marker = document.createElement('div'); marker.className = 'lct-static-cell';
                    marker.style.position = 'absolute'; marker.style.width = `${cellSize}px`; marker.style.height = `${cellSize}px`;
                    marker.style.transition = 'all 0.8s cubic-bezier(0.68, -0.55, 0.27, 1.55)';
                    grid.appendChild(marker); markers[i] = marker;
                }
                return { wrapper, grid, staticCells, markers };
            },
            runAnimation(type) {
                const explorer = this.explorers[type]; if (!explorer) return;
                const { config, scenarioLabel, grids, caseIndex } = explorer;
                const currentCase = config.animation[caseIndex];
                scenarioLabel.textContent = `Scenario: ${currentCase.label}`;
                grids.forEach((gridInstance, i) => {
                    const isWithLCT = i === 1;
                    gridInstance.staticCells.forEach(cell => cell.classList.remove('highlight'));
                    Object.entries(gridInstance.markers).forEach(([genIndexStr, marker]) => {
                        const genIndex = parseInt(genIndexStr, 10);
                        const refIndex = currentCase.mapping[genIndex];
                        marker.textContent = storyChunks[config.textIndices[genIndex]];
                        const col = genIndex; const row = config.size - 1 - refIndex;
                        const cellSize = 70; const gap = 4;
                        const x = col * (cellSize + gap); const y = row * (cellSize + gap);
                        marker.style.transform = `translate(${x}px, ${y}px)`;
                        let status = 'standard'; const rawDistance = Math.abs(genIndex - refIndex);
                        if (rawDistance > 0) { 
                            // For NAS-L, determine if segment would be calculable
                            if (isWithLCT && rawDistance <= config.size - 1) status = 'lct-capped'; 
                            else if (!isWithLCT && rawDistance > 0) status = 'invalid';
                            else status = 'invalid';
                        }
                        marker.style.backgroundColor = status === 'invalid' ? '#fee2e2' : status === 'lct-capped' ? '#fef3c7' : '#f0fdf4';
                        marker.style.borderColor = status === 'invalid' ? '#fca5a5' : status === 'lct-capped' ? '#fbbf24' : '#86efac';
                        if (status === 'lct-capped' || (status === 'standard' && isWithLCT)) {
                             for(let y_idx = 0; y_idx < config.size; y_idx++) {
                                  if (Math.abs(y_idx - genIndex) <= config.size - 1) {
                                      const targetCellIndex = (config.size - 1 - y_idx) * config.size + genIndex;
                                      if(gridInstance.staticCells[targetCellIndex]) { gridInstance.staticCells[targetCellIndex].classList.add('highlight'); }
                                  }
                             }
                        }
                    });
                });
                explorer.caseIndex = (caseIndex + 1) % config.animation.length;
            }
        };

        // Dynamic background
        function updateDynamicBackground(score) {
            const hue = 120 * score; const saturation = 30 + 40 * score; const lightness = 85 + 10 * score;
            const startColor = `hsl(170, ${saturation-10}%, ${lightness-5}%)`;
            const endColor = `hsl(190, ${saturation}%, ${lightness}%)`;
            elements.appBackground.style.background = `linear-gradient(135deg, ${startColor} 0%, ${endColor} 100%)`;
        }

        // LCT descriptions
        function updateLctDescription() {
            const lctValue = parseInt(elements.lctSlider.value);
            const descriptions = [
                "Tolerance: 0 blocks (Strict calculation)",
                "Tolerance: Low (2×2 neighbor rotations calculable)",
                "Tolerance: Moderate (3×3 group rotations calculable)",
                "Tolerance: High (4×4 block rotations calculable)",
                "Tolerance: Very High (5×5 section rotations calculable)",
                "Tolerance: Extreme (6×6 region rotations calculable)",
                "Tolerance: Maximum (7×7 area rotations calculable)",
                "Tolerance: Ultra (8×8 zone rotations calculable)",
                "Tolerance: Complete (9×9 full rotations calculable)"
            ];
            const colors = ['border-red-200 bg-red-50', 'border-purple-200 bg-purple-50', 'border-blue-200 bg-blue-50', 'border-green-200 bg-green-50', 'border-yellow-200 bg-yellow-50', 'border-orange-200 bg-orange-50', 'border-pink-200 bg-pink-50', 'border-indigo-200 bg-indigo-50', 'border-gray-200 bg-gray-50'];
            elements.lctDescription.innerHTML = `<div class="p-2 rounded border ${colors[Math.min(lctValue, 8)]}">${descriptions[Math.min(lctValue, 8)]}</div>`;
        }

        // Core algorithms
        function get_mapping_windows_js(refLen, genLen) {
            const isRefLonger = refLen >= genLen; const longerLen = isRefLonger ? refLen : genLen; const shorterLen = isRefLonger ? genLen : refLen;
            if (shorterLen === 0) return { precision_windows: [] };
            const slope = longerLen / shorterLen; const mappingWindowHeight = Math.ceil(slope);
            let direct_windows = [];
            for (let i = 0; i < shorterLen; i++) {
                const idx_point = i * slope; const start = Math.max(Math.floor(idx_point), 0);
                const end = Math.min(start + mappingWindowHeight, longerLen);
                direct_windows.push({ start, end });
            }
            let precision_windows_for_gen_chunks;
            if (isRefLonger) {
                precision_windows_for_gen_chunks = direct_windows;
            } else {
                precision_windows_for_gen_chunks = [];
                for (let genIdx = 0; genIdx < genLen; genIdx++) {
                    let mappedRefIndices = [];
                    direct_windows.forEach((ref_window_on_gen_axis, refIdx) => {
                        if (genIdx >= ref_window_on_gen_axis.start && genIdx < ref_window_on_gen_axis.end) mappedRefIndices.push(refIdx);
                    });
                    if (mappedRefIndices.length > 0) {
                        precision_windows_for_gen_chunks.push({ start: Math.min(...mappedRefIndices), end: Math.max(...mappedRefIndices) + 1 });
                    } else {
                        const proportionalRefPos = Math.floor((genIdx / genLen) * refLen);
                        precision_windows_for_gen_chunks.push({ start: proportionalRefPos, end: Math.min(proportionalRefPos + 1, refLen)});
                    }
                }
            }
            return { precision_windows: precision_windows_for_gen_chunks.map(w => ({start: w.start, end: Math.max(w.start +1, w.end)})) };
        }

        function computeIdealNarrativeLineBandJS(mappingWindows, numGenChunks, numRefChunks) {
            const n_windows = mappingWindows.length;
            if (n_windows <= 1) return { shortest_line: 0.0, longest_line: 0.0, floor_path: [], ceil_path: [] };
            
            let dp_min_list = [], dp_max_list = [], pred_min_list = [], pred_max_list = [];
            for (let i = 0; i < n_windows; i++) {
                const { start, end } = mappingWindows[i]; const window_height = Math.max(1, end - start);
                dp_min_list.push(Array(window_height).fill(Infinity)); dp_max_list.push(Array(window_height).fill(-Infinity));
                pred_min_list.push(Array(window_height).fill(-1)); pred_max_list.push(Array(window_height).fill(-1));
            }
            
            if (mappingWindows[0]){
                const { start: start0, end: end0 } = mappingWindows[0]; const window0_height = Math.max(1, end0 - start0);
                for (let y_offset = 0; y_offset < window0_height; y_offset++) {
                    if (dp_min_list[0] && dp_min_list[0][y_offset] !== undefined) { 
                        dp_min_list[0][y_offset] = 0; dp_max_list[0][y_offset] = 0;
                    }
                }
            }

            for (let i = 1; i < n_windows; i++) {
                 if (!mappingWindows[i-1] || !mappingWindows[i]) continue;
                const { start: curr_start, end: curr_end } = mappingWindows[i]; const curr_window_height = Math.max(1, curr_end - curr_start);
                const { start: prev_start, end: prev_end } = mappingWindows[i-1]; const prev_window_height = Math.max(1, prev_end - prev_start);
                for (let y_curr_offset = 0; y_curr_offset < curr_window_height; y_curr_offset++) {
                    const curr_y_abs = curr_start + y_curr_offset;
                    for (let y_prev_offset = 0; y_prev_offset < prev_window_height; y_prev_offset++) {
                        const prev_y_abs = prev_start + y_prev_offset; const dx_val = 1; const dy_val = curr_y_abs - prev_y_abs;
                        const distance = Math.sqrt(dx_val*dx_val + dy_val*dy_val);
                        if (dp_min_list[i-1] && dp_min_list[i-1][y_prev_offset] !== undefined && dp_min_list[i] && dp_min_list[i][y_curr_offset] !== undefined) {
                            if (dp_min_list[i-1][y_prev_offset] + distance < dp_min_list[i][y_curr_offset]) {
                                dp_min_list[i][y_curr_offset] = dp_min_list[i-1][y_prev_offset] + distance; pred_min_list[i][y_curr_offset] = y_prev_offset;
                            }
                        }
                        if (dp_max_list[i-1] && dp_max_list[i-1][y_prev_offset] !== undefined && dp_max_list[i] && dp_max_list[i][y_curr_offset] !== undefined) {
                            if (dp_max_list[i-1][y_prev_offset] !== -Infinity && dp_max_list[i-1][y_prev_offset] + distance > dp_max_list[i][y_curr_offset]) {
                                dp_max_list[i][y_curr_offset] = dp_max_list[i-1][y_prev_offset] + distance; pred_max_list[i][y_curr_offset] = y_prev_offset;
                            }
                        }
                    }
                }
            }

            let shortest_line = 0, longest_line = 0, shortest_end_y_offset = 0, longest_end_y_offset = 0;
            if (n_windows > 0 && mappingWindows[n_windows -1]) {
                const last_window_idx = n_windows - 1; const { start: last_start, end: last_end } = mappingWindows[last_window_idx];
                const last_window_height = Math.max(1, last_end - last_start); shortest_line = Infinity;
                if (dp_min_list[last_window_idx] && dp_min_list[last_window_idx].length > 0) {
                    for (let y_offset = 0; y_offset < last_window_height; y_offset++) {
                        if (dp_min_list[last_window_idx][y_offset] < shortest_line) {
                            shortest_line = dp_min_list[last_window_idx][y_offset]; shortest_end_y_offset = y_offset;
                        }
                    }
                }
                if (shortest_line === Infinity) shortest_line = 0;
                longest_line = -Infinity;
                if (dp_max_list[last_window_idx] && dp_max_list[last_window_idx].length > 0) {
                    for (let y_offset = 0; y_offset < last_window_height; y_offset++) {
                        if (dp_max_list[last_window_idx][y_offset] > longest_line) {
                            longest_line = dp_max_list[last_window_idx][y_offset]; longest_end_y_offset = y_offset;
                        }
                    }
                }
                 if (longest_line === -Infinity) longest_line = shortest_line;
            }

            let floor_path = [];
            if (n_windows > 0) {
                let current_y_offset_min = shortest_end_y_offset;
                for (let i = n_windows - 1; i >= 0; i--) {
                    if (!mappingWindows[i] || !pred_min_list[i] || (pred_min_list[i][current_y_offset_min] === undefined && i > 0)) break;
                    const y_abs = mappingWindows[i].start + current_y_offset_min; floor_path.unshift({ x: i, y: y_abs });
                    if (i > 0) {
                        if (pred_min_list[i][current_y_offset_min] === -1 || pred_min_list[i][current_y_offset_min] === undefined) break;
                        current_y_offset_min = pred_min_list[i][current_y_offset_min];
                    }
                }
            }
            
            let ceil_path = [];
            if (n_windows > 0) {
                let current_y_offset_max = longest_end_y_offset;
                for (let i = n_windows - 1; i >= 0; i--) {
                     if (!mappingWindows[i] || !pred_max_list[i] || (pred_max_list[i][current_y_offset_max] === undefined && i > 0)) break;
                    const y_abs = mappingWindows[i].start + current_y_offset_max; ceil_path.unshift({ x: i, y: y_abs });
                    if (i > 0) {
                         if (pred_max_list[i][current_y_offset_max] === -1 || pred_max_list[i][current_y_offset_max] === undefined) break;
                        current_y_offset_max = pred_max_list[i][current_y_offset_max];
                    }
                }
            }
            return { shortest_line, longest_line, floor_path, ceil_path };
        }

        function generateFloorPathDyMap(floorPath) {
            const dyMap = {}; if (!floorPath || floorPath.length < 2) return dyMap;
            for (let i = 0; i < floorPath.length - 1; i++) {
                const p1 = floorPath[i]; const p2 = floorPath[i+1];
                if (p2.x - p1.x === 1) dyMap[p1.x] = p2.y - p1.y;
            }
            return dyMap;
        }
        
        function computeActualLineLengthJS(actualPathPoints, totalRefChunks, totalGenChunks, lctValue, localFloorPathDyMap) {
            if (!actualPathPoints || actualPathPoints.length <= 1) {
                return { totalLength: 0.0, segments: [], lct_window_base: 0, expanded_lct_window: 0 };
            }
            const sortedPath = [...actualPathPoints].sort((a,b) => a.x - b.x);
            let currentTotalLength = 0; let pathSegments = [];
            const mappingWindowHeight = totalGenChunks > 0 ? Math.ceil(totalRefChunks / totalGenChunks) : 0;
            const ratio = totalGenChunks > 0 ? totalRefChunks / totalGenChunks : 0;
            const ratioDecimalPart = ratio - Math.floor(ratio);
            let lct_window_base;
            if (totalRefChunks <= totalGenChunks) {
                lct_window_base = mappingWindowHeight;
            } else {
                if (ratioDecimalPart > 0 && ratioDecimalPart <= 0.5) {
                    lct_window_base = (2 * mappingWindowHeight) - 2;
                } else {
                    lct_window_base = (2 * mappingWindowHeight) - 1;
                }
            }
            lct_window_base = Math.max(0, lct_window_base);
            let expanded_lct_window;
            if (totalRefChunks <= totalGenChunks) {
                expanded_lct_window = lctValue > 0 ? lct_window_base + (mappingWindowHeight * lctValue) : lct_window_base;
            } else {
                if (ratioDecimalPart > 0 && ratioDecimalPart <= 0.5) {
                    expanded_lct_window = lctValue > 0 ? lct_window_base + ((mappingWindowHeight - 1) * lctValue) : lct_window_base;
                } else {
                    expanded_lct_window = lctValue > 0 ? lct_window_base + (mappingWindowHeight * lctValue) : lct_window_base;
                }
            }
            
            for (let i = 0; i < sortedPath.length - 1; i++) {
                const p1 = sortedPath[i]; const p2 = sortedPath[i+1];
                const dx_segment = p2.x - p1.x; const dy_segment_raw = p2.y - p1.y;
                if (dx_segment <= 0) continue;
                
                const dy_for_eval = lctValue > 0 ? Math.abs(dy_segment_raw) : dy_segment_raw;
                let segmentLength = 0; let calculation_method = "invalid"; let is_calculable = false;
                
                if (dy_for_eval <= lct_window_base && dy_for_eval >= 0) {
                    segmentLength = Math.sqrt(dx_segment**2 + dy_segment_raw**2);
                    is_calculable = true; calculation_method = "standard";
                } 
                else if (lctValue > 0 && dy_for_eval > lct_window_base && dy_for_eval <= expanded_lct_window) {
                    let floor_dy_val = dy_segment_raw; 
                    if (localFloorPathDyMap && localFloorPathDyMap.hasOwnProperty(p1.x)) {
                        floor_dy_val = Math.abs(localFloorPathDyMap[p1.x]);
                    }
                    segmentLength = Math.sqrt(dx_segment**2 + floor_dy_val**2);
                    is_calculable = true; calculation_method = "lct-capped";
                }
                
                currentTotalLength += segmentLength;
                pathSegments.push({
                    start: {x: p1.x, y: p1.y}, end: {x: p2.x, y: p2.y}, dx: dx_segment, dy: dy_segment_raw,
                    threshold: lct_window_base, threshold_with_lct: expanded_lct_window,
                    is_calculable: is_calculable, calculation_method: calculation_method, length: segmentLength
                });
            }
            return { totalLength: currentTotalLength, segments: pathSegments, lct_window_base: lct_window_base, expanded_lct_window: expanded_lct_window };
        }

        function calculateLineNAS(floorLength, ceilLength, actualLength) {
            const fl = Math.max(0, floorLength); const cl = Math.max(0, ceilLength); const al = Math.max(0, actualLength);
            if (fl === 0 && cl === 0 && al === 0) return 1.0;
            if (fl === 0 && al === 0) return 1.0;
            if (fl <= al && al <= cl) return 1.0;
            else if (al < fl) return fl > 0 ? al / fl : 0.0;
            else return al > 0 ? cl / al : 0.0;
        }

        // --- HOVER CONE FUNCTIONS ---
        function drawHoverCone(markerId) {
            clearHoverCone();
            const marker = markers_config.find(m => m.id === markerId);
            if (!marker || marker.currentX >= numUnitsX - 1) return;
            
            const chartWidthPx = elements.chartGrid.clientWidth;
            const chartHeightPx = elements.chartGrid.clientHeight;
            if (chartWidthPx === 0 || chartHeightPx === 0) return;
            
            const cellWidthPx = chartWidthPx / numUnitsX;
            const cellHeightPx = chartHeightPx / numUnitsY;
            
            const startX = (marker.currentX + 0.5) * cellWidthPx;
            const startY = chartHeightPx - ((marker.currentY + 0.5) * cellHeightPx);
            const endX = (marker.currentX + 1.5) * cellWidthPx;
            
            const baseWindow = currentLctWindowBase;
            const expandedWindow = currentExpandedLctWindow;
            
            const coneGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            coneGroup.id = 'hover-cone-group';
            
            if (currentLct === 0) {
                const topYStandard = Math.max(0, chartHeightPx - ((marker.currentY + baseWindow + 0.5) * cellHeightPx));
                const bottomYStandard = Math.min(chartHeightPx, chartHeightPx - ((marker.currentY + 0.5) * cellHeightPx));
                
                const standardCone = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                const pointsStandard = `${startX},${startY} ${endX},${topYStandard} ${endX},${bottomYStandard}`;
                standardCone.setAttribute('points', pointsStandard);
                standardCone.setAttribute('class', 'hover-cone-standard');
                coneGroup.appendChild(standardCone);
            } else {
                const topY = Math.max(0, chartHeightPx - ((marker.currentY + expandedWindow + 0.5) * cellHeightPx));
                const bottomY = Math.min(chartHeightPx, chartHeightPx - ((marker.currentY - expandedWindow + 0.5) * cellHeightPx));
                
                const lctCappedCone = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                const points = `${startX},${startY} ${endX},${topY} ${endX},${bottomY}`;
                lctCappedCone.setAttribute('points', points);
                lctCappedCone.setAttribute('class', 'hover-cone-lct-capped');
                coneGroup.appendChild(lctCappedCone);
            }
            
            elements.actualPathSvg.appendChild(coneGroup);
        }

        function clearHoverCone() {
            const existingCone = document.getElementById('hover-cone-group');
            if (existingCone) {
                existingCone.remove();
            }
        }

        // Animation helper
        function animateNumber(el, start, end, duration = 400) {
            if (Math.abs(end - start) < 0.001) { el.textContent = end.toFixed(el.id.includes("Score") ? 3 : 2); return; }
            const frame = (ct) => {
                const elapsed = ct - st; const rawProgress = Math.min(elapsed / duration, 1);
                const progress = easeOutCubic(rawProgress); const current = start + (end - start) * progress;
                el.textContent = current.toFixed(el.id.includes("Score") ? 3 : 2);
                if (rawProgress < 1) requestAnimationFrame(frame);
            };
            const st = performance.now(); requestAnimationFrame(frame);
        }

        // Preview functions
        function showScorePreview(tempMarkers, lctValue) {
            if (!tempMarkers) return;
            const sortedMarkers = [...tempMarkers].sort((a, b) => a.currentX - b.currentX);
            const pathData = sortedMarkers.map(marker => ({ x: marker.currentX, y: marker.currentY }));
            const lengthData = computeActualLineLengthJS(pathData, numUnitsY, numUnitsX, lctValue, floorPathDyMap);
            const previewActualLength = lengthData.totalLength;
            const previewLineNas = calculateLineNAS(currentFloorLength, currentCeilLength, previewActualLength);
            elements.nasLScorePreview.textContent = `→ ${previewLineNas.toFixed(3)}`;
            elements.actualLengthPreview.textContent = `→ ${previewActualLength.toFixed(2)}`;
        }
        function hideScorePreview() { elements.nasLScorePreview.textContent = ''; elements.actualLengthPreview.textContent = ''; }

        // Tooltip functions
        function updateChartTooltip(e, markerId) {
            const marker = markers_config.find(m => m.id === markerId);
            if (!marker) return;
            elements.chartTooltip.classList.add('visible');
            elements.chartTooltip.style.left = `${e.clientX + 15}px`;
            elements.chartTooltip.style.top = `${e.clientY + 15}px`;
            const segment = currentActualPathSegments.find(s => s.start.x === marker.currentX && s.start.y === marker.currentY);
            const mappingText = `Gen Chunk ${marker.id} → Ref Chunk ${marker.currentY}`;
            let statusClass, segmentText;
            
            if (segment) {
                if (segment.calculation_method === 'standard') {
                    statusClass = 'standard';
                    segmentText = `<hr class="my-1 border-slate-500"><strong class="text-green-400">In Window (Standard)</strong><br>|Δy|: ${Math.abs(segment.dy).toFixed(1)}, Base: ${segment.threshold.toFixed(1)}`;
                } else if (segment.calculation_method === 'lct-capped') {
                    statusClass = 'lct-capped';
                    segmentText = `<hr class="my-1 border-slate-500"><strong class="text-yellow-400">Outside Window (Capped)</strong><br>|Δy|: ${Math.abs(segment.dy).toFixed(1)}, Exp: ${segment.threshold_with_lct.toFixed(1)}`;
                } else { // 'invalid'
                    statusClass = 'invalid';
                    segmentText = `<hr class="my-1 border-slate-500"><strong class="text-red-400">Outside Window (Invalid)</strong><br>|Δy|: ${Math.abs(segment.dy).toFixed(1)}, Exp: ${segment.threshold_with_lct.toFixed(1)}`;
                }
            } else {
                statusClass = 'standard';
                segmentText = `<hr class="my-1 border-slate-500">End of path`;
            }
            elements.chartTooltip.className = `visible ${statusClass}`;
            elements.chartTooltip.innerHTML = mappingText + segmentText;
        }

        function hideChartTooltip() { elements.chartTooltip.classList.remove('visible', 'standard', 'lct-capped', 'invalid'); }

        // Rendering functions
        function updateGridBackground() {
            elements.chartGrid.style.backgroundSize = `calc(100% / ${numUnitsX}) calc(100% / ${numUnitsY})`;
        }

        function renderIdealMappingWindows() {
            elements.idealMappingContainer.innerHTML = '';
            currentPrecisionWindows.forEach((window, gen_chunk_idx) => {
                const idealWindowDiv = document.createElement('div');
                idealWindowDiv.classList.add('ideal-mapping-window');
                idealWindowDiv.style.left = `calc(${gen_chunk_idx} * 100% / ${numUnitsX})`;
                idealWindowDiv.style.width = `calc(100% / ${numUnitsX})`;
                idealWindowDiv.style.bottom = `calc(${window.start} * 100% / ${numUnitsY})`;
                idealWindowDiv.style.height = `calc(${(window.end - window.start)} * 100% / ${numUnitsY})`;
                elements.idealMappingContainer.appendChild(idealWindowDiv);
            });
        }

        function drawPathAndMarkersOnSvg(svgElement, pathData, lineClass, markerFillColor, markerStrokeColor) {
            const chartWidthPx = elements.chartGrid.clientWidth; const chartHeightPx = elements.chartGrid.clientHeight;
            if (numUnitsX === 0 || numUnitsY === 0 || chartWidthPx === 0 || chartHeightPx === 0 || !pathData || pathData.length === 0) return;
            const cellWidthPx = chartWidthPx / numUnitsX; const cellHeightPx = chartHeightPx / numUnitsY;
            if (pathData.length >= 2) {
                const points = pathData.map(p => {
                    const svgX = (p.x + 0.5) * cellWidthPx; const svgY = chartHeightPx - ((p.y + 0.5) * cellHeightPx);
                    return `${svgX},${svgY}`;
                }).join(' ');
                const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
                polyline.setAttribute('points', points);
                polyline.setAttribute('class', lineClass);
                svgElement.appendChild(polyline);
            }
        }

        function renderIdealPaths() {
            elements.idealPathsSvg.innerHTML = '';
            drawPathAndMarkersOnSvg(elements.idealPathsSvg, currentFloorPath, 'floor-path-line', '#93c5fd', '#0ea5e9');
            drawPathAndMarkersOnSvg(elements.idealPathsSvg, currentCeilPath, 'ceil-path-line', '#f9a8d4', '#ec4899');
        }

        function drawSegmentClassifications(svgElement, pathSegments, animated = false) {
            if (!pathSegments || pathSegments.length === 0) return;
            const chartWidthPx = elements.chartGrid.clientWidth;
            const chartHeightPx = elements.chartGrid.clientHeight;
            if (chartWidthPx === 0 || chartHeightPx === 0) return;
            const cellWidthPx = chartWidthPx / numUnitsX;
            const cellHeightPx = chartHeightPx / numUnitsY;

            pathSegments.forEach(segment => {
                const x1 = (segment.start.x + 0.5) * cellWidthPx;
                const y1 = chartHeightPx - ((segment.start.y + 0.5) * cellHeightPx);
                const x2 = (segment.end.x + 0.5) * cellWidthPx;
                const y2 = chartHeightPx - ((segment.end.y + 0.5) * cellHeightPx);
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x1);
                line.setAttribute('y1', y1);
                line.setAttribute('x2', x2);
                line.setAttribute('y2', y2);
                let className = 'path-segment-invalid';
                if (segment.calculation_method === 'standard') {
                    className = 'path-segment-standard';
                } else if (segment.calculation_method === 'lct-capped') {
                    className = 'path-segment-lct-capped';
                }
                line.setAttribute('class', className);

                // FIXED: Append the line to the DOM FIRST, then get its length.
                svgElement.appendChild(line);

                if (animated) {
                    try {
                        const length = line.getTotalLength();
                        line.style.strokeDasharray = length;
                        line.style.strokeDashoffset = length;
                        // Use requestAnimationFrame to ensure the style is applied after the element is in the DOM.
                        requestAnimationFrame(() => {
                           line.style.animation = 'drawLine 0.5s ease-out forwards';
                        });
                    } catch (error) {
                        // This catch block handles cases where the element might still not be ready,
                        // although appending it first should prevent this.
                        console.error("Could not animate line segment:", error);
                    }
                }
            });
        }


        function renderActualPath(animated = false) {
            if (markers_config.length === 0) {
                 elements.actualPathSvg.innerHTML = ''; animateNumber(elements.actualLengthDisplay, parseFloat(elements.actualLengthDisplay.textContent)||0, 0);
                 elements.calculableSegmentsDisplay.textContent = '0/0'; currentActualPathSegments = [];
                 currentLctWindowBase = 0; currentExpandedLctWindow = 0; currentActualLength = 0; 
                 currentLineNas = calculateLineNAS(currentFloorLength, currentCeilLength, currentActualLength); 
                 animateNumber(elements.nasLScoreDisplay, parseFloat(elements.nasLScoreDisplay.textContent)||0, currentLineNas);
                 updateDynamicBackground(currentLineNas); return;
            }
            const sortedMarkers = [...markers_config].sort((a, b) => a.currentX - b.currentX);
            const pathData = sortedMarkers.map(marker => ({ x: marker.currentX, y: marker.currentY }));
            elements.actualPathSvg.innerHTML = '';
            
            const lengthAndSegmentData = computeActualLineLengthJS(pathData, numUnitsY, numUnitsX, currentLct, floorPathDyMap);
            const prevActualLength = currentActualLength; const prevLineNas = currentLineNas;
            currentActualLength = lengthAndSegmentData.totalLength; currentActualPathSegments = lengthAndSegmentData.segments;
            currentLctWindowBase = lengthAndSegmentData.lct_window_base; currentExpandedLctWindow = lengthAndSegmentData.expanded_lct_window; 
            
            drawSegmentClassifications(elements.actualPathSvg, currentActualPathSegments, animated);
            
            animateNumber(elements.actualLengthDisplay, prevActualLength, currentActualLength);
            const calculableSegments = currentActualPathSegments.filter(s => s.is_calculable).length;
            elements.calculableSegmentsDisplay.textContent = `${calculableSegments}/${currentActualPathSegments.length}`;
            elements.lctWindowBaseDisplay.textContent = currentLctWindowBase.toFixed(1);
            elements.expandedWindowDisplay.textContent = currentExpandedLctWindow.toFixed(1);

            currentLineNas = calculateLineNAS(currentFloorLength, currentCeilLength, currentActualLength);
            animateNumber(elements.nasLScoreDisplay, prevLineNas, currentLineNas); updateDynamicBackground(currentLineNas);
        }
        
        function renderGenChunkMarkers() {
            renderActualPath(); elements.genChunkMarkerContainer.innerHTML = '';
            if (numUnitsX === 0 || numUnitsY === 0) return;
            markers_config.forEach(markerData => {
                const markerDiv = document.createElement('div');
                markerDiv.classList.add('gen-marker'); markerDiv.setAttribute('draggable', 'true');
                markerDiv.dataset.id = markerData.id;
                const markerWidth = 12; const markerHeight = 12;
                markerDiv.style.width = `${markerWidth}px`; markerDiv.style.height = `${markerHeight}px`;
                markerDiv.style.left = `calc(${markerData.currentX} * 100% / ${numUnitsX} + (100% / ${numUnitsX} / 2) - ${markerWidth/2}px)`;
                markerDiv.style.bottom = `calc(${markerData.currentY} * 100% / ${numUnitsY} + (100% / ${numUnitsY} / 2) - ${markerHeight/2}px)`;
                
                markerDiv.addEventListener('dragstart', handleDragStart);
                markerDiv.addEventListener('dragend', handleDragEnd);
                markerDiv.addEventListener('mouseover', e => { 
                    if (!isMarkerDragging) {
                        updateChartTooltip(e, markerData.id);
                        hoveredMarkerId = markerData.id;
                        drawHoverCone(markerData.id);
                    }
                });
                markerDiv.addEventListener('mouseout', () => { 
                    if (!isMarkerDragging) {
                        hideChartTooltip();
                        hoveredMarkerId = null;
                        clearHoverCone();
                    }
                });
                elements.genChunkMarkerContainer.appendChild(markerDiv);
            });
        }

        function renderAnimatedMarkers(animatedMarkers) {
            elements.genChunkMarkerContainer.innerHTML = '';
            const lctValue = parseInt(elements.lctSlider.value);
            animatedMarkers.forEach(markerData => {
                if (typeof markerData.opacity !== 'number' || markerData.opacity > 0.01) {
                    const markerDiv = document.createElement('div');
                    markerDiv.className = 'gen-marker'; markerDiv.dataset.id = markerData.id;
                    markerDiv.style.left = `calc(${(markerData.currentX + 0.5)}*100%/${numUnitsX} - 6px)`;
                    markerDiv.style.bottom = `calc(${(markerData.currentY + 0.5)}*100%/${numUnitsY} - 6px)`;
                    markerDiv.style.opacity = markerData.opacity;
                    elements.genChunkMarkerContainer.appendChild(markerDiv);
                }
            });
        }

        function renderDropTargetCells(force = false) {
            if (elements.dropTargetCellContainer.childElementCount > 0 && !force) return;
            elements.dropTargetCellContainer.innerHTML = '';
            for (let y_idx = 0; y_idx < numUnitsY; y_idx++) {
                for (let x_idx = 0; x_idx < numUnitsX; x_idx++) {
                    const cell = document.createElement('div');
                    cell.classList.add('grid-cell-overlay'); cell.dataset.x = x_idx; cell.dataset.y = y_idx;
                    cell.style.width = `calc(100% / ${numUnitsX})`; cell.style.height = `calc(100% / ${numUnitsY})`;
                    cell.style.left = `calc(${x_idx} * 100% / ${numUnitsX})`; cell.style.bottom = `calc(${y_idx} * 100% / ${numUnitsY})`;
                    cell.addEventListener('dragover', handleDragOver); cell.addEventListener('dragleave', handleDragLeave);
                    cell.addEventListener('drop', handleDrop); elements.dropTargetCellContainer.appendChild(cell);
                }
            }
        }
        
        function renderAxisLabels() {
            elements.axisLabelContainerX.innerHTML = ''; elements.axisLabelContainerY.innerHTML = '';
            if (numUnitsX <= 0 || numUnitsY <= 0) return; 
            const yStep = Math.max(1, Math.floor(numUnitsY / 8)) || 1; const xStep = Math.max(1, Math.floor(numUnitsX / 8)) || 1;
            for (let i = 0; i < numUnitsY; i += yStep) {
                const tickLabelY = document.createElement('div'); tickLabelY.classList.add('axis-label');
                tickLabelY.textContent = i; tickLabelY.style.left = '-2rem';
                tickLabelY.style.bottom = `calc((${i} + 0.5) * 100% / ${numUnitsY})`; 
                tickLabelY.style.transform = 'translateY(50%)'; elements.axisLabelContainerY.appendChild(tickLabelY);
            }
            for (let i = 0; i < numUnitsX; i += xStep) {
                const tickLabelX = document.createElement('div'); tickLabelX.classList.add('axis-label');
                tickLabelX.textContent = i; tickLabelX.style.bottom = '-1.5rem';
                tickLabelX.style.left = `calc((${i} + 0.5) * 100% / ${numUnitsX})`; 
                tickLabelX.style.transform = 'translateX(-50%)'; elements.axisLabelContainerX.appendChild(tickLabelX);
            }
        }

        function renderAll() { 
            updateGridBackground(); 
            renderIdealMappingWindows(); 
            renderIdealPaths(); 
            renderDropTargetCells(true); 
            renderAxisLabels(); 
            renderGenChunkMarkers(); 
        }

        // --- ENHANCED SCENARIO & GRID ANIMATION SYSTEM ---
        function getScenarioConfig(scenarioType) {
            let config = { targetRefLen: 10, targetGenLen: 10, yMapping: (i) => i };
            switch(scenarioType) {
                case 'optimal': break;
                case 'lct1Rotation': config.yMapping = (i) => (i === 0) ? 1 : (i === 1) ? 0 : i; break;
                case 'lct2Rotation': config.yMapping = (i) => (i === 0) ? 1 : (i === 1) ? 2 : (i === 2) ? 0 : i; break;
                case 'deleteEnd': config.targetGenLen = 7; break;
                case 'deleteBegin': config.targetGenLen = 7; config.yMapping = (i) => i + 3; break;
                case 'deleteMiddle': config.targetGenLen = 7; config.yMapping = (i) => (i < 3) ? i : i + 3; break;
            }
            return config;
        }

        function updateScenarioTip(scenarioType) {
            const tips = {
                optimal: "This is a perfect 1-to-1 alignment along the optimal path. All segments are standard and calculable, resulting in optimal NAS-L score.",
                lct1Rotation: "A minor 2x2 reordering. Without LCT, this creates invalid segments. Set LCT=1 to see them become LCT-capped, improving calculability.",
                lct2Rotation: "A more complex 3x3 rotation. This requires LCT=2 to make segments calculable. Notice how segments transition from invalid to LCT-capped.",
                deleteEnd: "The generated sequence is shorter, ending prematurely. This affects path length calculation and reduces the total calculable segments.",
                deleteMiddle: "A gap in the middle creates discontinuous segments. Some become invalid while others may remain calculable depending on LCT.",
                deleteBegin: "Missing the start creates significant displacement. Most segments become invalid without sufficient LCT tolerance."
            };
            document.getElementById('scenarioTip').innerHTML = `<p><strong>Tip:</strong> ${tips[scenarioType] || tips.optimal}</p>`;
        }

        function computeAnimatedSegments(animatedMarkers, lctValue, floorPathDyMap) {
            const visibleMarkers = animatedMarkers.filter(m => m.opacity > 0.01);
            if (visibleMarkers.length <= 1) return [];
            
            const sortedMarkers = [...visibleMarkers].sort((a, b) => a.currentX - b.currentX);
            const pathData = sortedMarkers.map(marker => ({ x: marker.currentX, y: marker.currentY }));
            const lengthData = computeActualLineLengthJS(pathData, numUnitsY, numUnitsX, lctValue, floorPathDyMap);
            return lengthData.segments;
        }

        function renderAnimatedSegments(segments) {
            const existingLines = elements.actualPathSvg.querySelectorAll('line, polygon');
            existingLines.forEach(line => {
                if(line.id !== 'hover-cone-group') line.remove();
            });
            
            if (segments && segments.length > 0) {
                drawSegmentClassifications(elements.actualPathSvg, segments, true);
            }
        }

        function animateToScenario(scenarioType) {
            const config = getScenarioConfig(scenarioType);
            updateScenarioTip(scenarioType);
            animateGridChange(config.targetGenLen, config.targetRefLen, config.yMapping);
        }
        
        function animateGridChange(targetGenLen, targetRefLen, yMapping = i => i) {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);

            // --- 1. Capture Start State ---
            const startPositions = JSON.parse(JSON.stringify(markers_config));
            const startFloorPath = JSON.parse(JSON.stringify(currentFloorPath));
            const startCeilPath = JSON.parse(JSON.stringify(currentCeilPath));
            const startGenLen = numUnitsX;
            const startRefLen = numUnitsY;
            const startFloorLength = currentFloorLength;
            const startCeilLength = currentCeilLength;
            const startActualLength = currentActualLength;
            const startNasL = currentLineNas;

            // --- 2. Update to Target Grid State (data) ---
            numUnitsY = targetRefLen;
            numUnitsX = targetGenLen;
            elements.refLenInput.value = numUnitsY;
            elements.genLenInput.value = numUnitsX;
            elements.lctSlider.max = Math.max(0, numUnitsY - 1);
            if (parseInt(elements.lctSlider.value) > elements.lctSlider.max) {
                elements.lctSlider.value = elements.lctSlider.max;
                elements.lctValueDisplay.textContent = elements.lctSlider.value;
                updateLctDescription();
            }
            currentLct = parseInt(elements.lctSlider.value, 10);
            
            // --- 3. Calculate Target Paths & Positions ---
            const windows = get_mapping_windows_js(numUnitsY, numUnitsX);
            currentPrecisionWindows = windows.precision_windows;
            const { shortest_line, longest_line, floor_path, ceil_path } = computeIdealNarrativeLineBandJS(currentPrecisionWindows, numUnitsX, numUnitsY);
            
            const targetFloorPath = floor_path;
            const targetCeilPath = ceil_path;
            const targetFloorLength = shortest_line;
            const targetCeilLength = longest_line;
            const targetDyMap = generateFloorPathDyMap(targetFloorPath);

            const targetPositions = [];
            for (let i = 0; i < numUnitsX; i++) {
                targetPositions.push({ id: i, currentX: i, currentY: yMapping(i) });
            }

            const targetLengthData = computeActualLineLengthJS(targetPositions.map(p => ({ x: p.currentX, y: p.currentY })), numUnitsY, numUnitsX, currentLct, targetDyMap);
            const targetActualLength = targetLengthData.totalLength;
            const targetNasL = calculateLineNAS(targetFloorLength, targetCeilLength, targetActualLength);

            // --- 4. Render Static Parts of Grid ---
            updateGridBackground();
            renderIdealMappingWindows();
            renderDropTargetCells(true);
            renderAxisLabels();

            // --- 5. Animate ---
            const duration = 800;
            const startTime = performance.now();

            function interpolatePath(start, end, progress) {
                const path = [];
                const len = end.length;
                if (len === 0) return [];

                for (let i = 0; i < len; i++) {
                    const endPoint = end[i];
                    // Find a proportional point in the start path for smooth y-transition
                    const start_i_float = start.length > 1 ? i / (len - 1) * (start.length - 1) : 0;
                    const start_i1 = Math.floor(start_i_float);
                    const start_i2 = Math.ceil(start_i_float);
                    const start_frac = start_i_float - start_i1;
                    const start_y = start.length > 0 ? (start[start_i1]?.y ?? endPoint.y) * (1 - start_frac) + (start[start_i2]?.y ?? endPoint.y) * start_frac : endPoint.y;
                    
                    const newY = start_y + (endPoint.y - start_y) * progress;
                    path.push({ x: endPoint.x, y: newY });
                }
                return path;
            }

            function tick(currentTime) {
                const elapsedTime = currentTime - startTime;
                const rawProgress = Math.min(elapsedTime / duration, 1);
                const progress = easeOutCubic(rawProgress);

                // Animate Ideal Paths
                const animatedFloorPath = interpolatePath(startFloorPath, targetFloorPath, progress);
                const animatedCeilPath = interpolatePath(startCeilPath, targetCeilPath, progress);
                elements.idealPathsSvg.innerHTML = '';
                drawPathAndMarkersOnSvg(elements.idealPathsSvg, animatedFloorPath, 'floor-path-line');
                drawPathAndMarkersOnSvg(elements.idealPathsSvg, animatedCeilPath, 'ceil-path-line');
                
                // Animate Markers
                const animatedMarkers = [];
                const maxMarkers = Math.max(startGenLen, numUnitsX);
                for (let i = 0; i < maxMarkers; i++) {
                    const startMarker = startPositions.find(m => m.id === i);
                    const targetMarker = targetPositions.find(m => m.id === i);
                    
                    if (startMarker && targetMarker) {
                        const newY = startMarker.currentY + (targetMarker.currentY - startMarker.currentY) * progress;
                        animatedMarkers.push({ ...targetMarker, currentY: newY, opacity: 1 });
                    } else if (!startMarker && targetMarker) {
                        const idealY = (targetFloorPath.find(p => p.x === i) || {y: Math.floor(numUnitsY/2)}).y;
                        const newY = idealY + (targetMarker.currentY - idealY) * progress;
                        animatedMarkers.push({ ...targetMarker, currentY: newY, opacity: progress });
                    } else if (startMarker && !targetMarker) {
                        animatedMarkers.push({ ...startMarker, opacity: 1 - progress });
                    }
                }
                renderAnimatedMarkers(animatedMarkers);

                // Animate Actual Path based on animated markers
                const animatedSegments = computeAnimatedSegments(animatedMarkers, currentLct, targetDyMap);
                renderAnimatedSegments(animatedSegments);

                // Animate Metrics
                elements.floorLengthDisplay.textContent = (startFloorLength + (targetFloorLength - startFloorLength) * progress).toFixed(2);
                elements.ceilLengthDisplay.textContent = (startCeilLength + (targetCeilLength - startCeilLength) * progress).toFixed(2);
                
                const currentAnimatedActualLength = computeActualLineLengthJS(animatedMarkers.map(m=>({x: m.currentX, y: m.currentY})), numUnitsY, numUnitsX, currentLct, targetDyMap).totalLength;
                elements.actualLengthDisplay.textContent = currentAnimatedActualLength.toFixed(2);

                const animatedNasL = calculateLineNAS(
                    parseFloat(elements.floorLengthDisplay.textContent),
                    parseFloat(elements.ceilLengthDisplay.textContent),
                    currentAnimatedActualLength
                );
                elements.nasLScoreDisplay.textContent = animatedNasL.toFixed(3);
                updateDynamicBackground(animatedNasL);
                
                const calculableSegments = animatedSegments.filter(s => s.is_calculable).length;
                elements.calculableSegmentsDisplay.textContent = `${calculableSegments}/${animatedSegments.length}`;
                
                if (rawProgress < 1) {
                    animationFrameId = requestAnimationFrame(tick);
                } else {
                    animationFrameId = null;
                    markers_config = targetPositions;
                    currentFloorPath = targetFloorPath;
                    currentCeilPath = targetCeilPath;
                    // Final render to clean up and set correct values
                    initializeStateAndRender();
                }
            }

            animationFrameId = requestAnimationFrame(tick);
        }


        // Drag and Drop Event Handlers
        function handleDragStart(e) {
            const markerElement = e.target.closest('.gen-marker'); if (!markerElement) return;
            draggedMarkerId = parseInt(markerElement.dataset.id, 10); markerElement.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move'; e.dataTransfer.setData('text/plain', draggedMarkerId);
            isMarkerDragging = true; hideChartTooltip(); clearHoverCone();
        }
        function handleDragEnd(e) {
            isMarkerDragging = false; document.querySelector(`.gen-marker[data-id='${draggedMarkerId}']`)?.classList.remove('dragging');
            hideScorePreview(); renderGenChunkMarkers();
        }
        function handleDragOver(e) {
            e.preventDefault(); e.dataTransfer.dropEffect = 'move';
            if (e.currentTarget.classList.contains('grid-cell-overlay')) {
                e.currentTarget.classList.add('drag-over');
                const targetX = parseInt(e.currentTarget.dataset.x);
                const targetY = parseInt(e.currentTarget.dataset.y);
                const tempMarkers = JSON.parse(JSON.stringify(markers_config));
                const draggedMarker = tempMarkers.find(m => m.id === draggedMarkerId);
                
                if (draggedMarker) {
                    const originalX = markers_config.find(m => m.id === draggedMarkerId).currentX;
                    const markerAtTarget = tempMarkers.find(m => m.currentX === targetX && m.id !== draggedMarkerId);

                    if (markerAtTarget && targetX !== originalX) {
                        markerAtTarget.currentX = originalX;
                    }
                    draggedMarker.currentX = targetX;
                    draggedMarker.currentY = targetY;
                    showScorePreview(tempMarkers, currentLct);
                }
            }
        }
        function handleDragLeave(e) {
            if (e.currentTarget.classList.contains('grid-cell-overlay')) e.currentTarget.classList.remove('drag-over');
        }
        function handleDrop(e) {
            e.preventDefault(); hideScorePreview();
            if (!e.currentTarget.classList.contains('grid-cell-overlay')) return;
            e.currentTarget.classList.remove('drag-over');
            const targetX = parseInt(e.currentTarget.dataset.x, 10); const targetY = parseInt(e.currentTarget.dataset.y, 10);
            const draggedMarkerData = markers_config.find(m => m.id === draggedMarkerId); if (!draggedMarkerData) return;
            const oldX = draggedMarkerData.currentX;
            const markerAtTargetXColumn = markers_config.find(m => m.currentX === targetX && m.id !== draggedMarkerId);
            if (markerAtTargetXColumn && targetX !== oldX) markerAtTargetXColumn.currentX = oldX;
            draggedMarkerData.currentX = targetX; draggedMarkerData.currentY = targetY;
            const markerElementDOM = elements.genChunkMarkerContainer.querySelector(`.gen-marker[data-id='${draggedMarkerId}']`);
            if(markerElementDOM) markerElementDOM.classList.remove('dragging');
            draggedMarkerId = null; renderGenChunkMarkers(); 
        }

        // Main initialization function
        function initializeStateAndRender() {
            numUnitsY = Math.max(1, Math.min(10, parseInt(elements.refLenInput.value, 10) || 1));
            numUnitsX = Math.max(1, Math.min(10, parseInt(elements.genLenInput.value, 10) || 1));
            currentLct = parseInt(elements.lctSlider.value, 10); elements.lctValueDisplay.textContent = currentLct;
            updateLctDescription();
            elements.refLenInput.value = numUnitsY; elements.genLenInput.value = numUnitsX;
            
            const windowsData = get_mapping_windows_js(numUnitsY, numUnitsX);
            currentPrecisionWindows = windowsData.precision_windows;
            
            if (currentPrecisionWindows && currentPrecisionWindows.length > 0 && numUnitsX > 0 && numUnitsY > 0) {
                const { shortest_line, longest_line, floor_path, ceil_path } = computeIdealNarrativeLineBandJS(currentPrecisionWindows, numUnitsX, numUnitsY);
                currentFloorPath = floor_path; currentCeilPath = ceil_path;
                const prevFloorLength = currentFloorLength; const prevCeilLength = currentCeilLength;
                currentFloorLength = shortest_line; currentCeilLength = longest_line;
                animateNumber(elements.floorLengthDisplay, prevFloorLength, currentFloorLength);
                animateNumber(elements.ceilLengthDisplay, prevCeilLength, currentCeilLength);
                floorPathDyMap = generateFloorPathDyMap(currentFloorPath);
            } else {
                currentFloorPath = []; currentCeilPath = []; currentFloorLength = 0; currentCeilLength = 0;
                animateNumber(elements.floorLengthDisplay, parseFloat(elements.floorLengthDisplay.textContent)||0, 0);
                animateNumber(elements.ceilLengthDisplay, parseFloat(elements.ceilLengthDisplay.textContent)||0, 0);
                floorPathDyMap = {}; currentLineNas = calculateLineNAS(0, 0, currentActualLength); 
                animateNumber(elements.nasLScoreDisplay, parseFloat(elements.nasLScoreDisplay.textContent)||0, currentLineNas);
            }

            const reinitializeMarkers = markers_config.length !== numUnitsX || !markers_config.every((m,i)=> m.id === i && m.currentX === i);
            if (reinitializeMarkers) {
                resetToOptimalOrder();
            } else {
                markers_config.forEach(marker => {
                    marker.currentY = Math.min(Math.max(0, marker.currentY), numUnitsY - 1);
                    marker.currentX = Math.min(Math.max(0, marker.currentX), numUnitsX - 1);
                });
                if (markers_config.length > numUnitsX) markers_config = markers_config.slice(0, numUnitsX);
                markers_config.sort((a,b) => a.currentX - b.currentX);
            }
            
            renderAll();
        }

        // Scenario functions
        function resetToOptimalOrder() {
            markers_config = [];
            for(let i = 0; i < numUnitsX; i++) {
                const idealYStart = (currentFloorPath.find(p => p.x === i) || {}).y ?? Math.floor(numUnitsY / 2);
                markers_config.push({ id: i, currentX: i, currentY: Math.min(idealYStart, numUnitsY - 1) });
            }
            updateScenarioTip('optimal'); renderGenChunkMarkers();
        }

        // Event Listeners
        function handleGridInputChange() {
            const targetRefLen = Math.max(1, Math.min(10, parseInt(elements.refLenInput.value, 10) || 1));
            const targetGenLen = Math.max(1, Math.min(10, parseInt(elements.genLenInput.value, 10) || 1));

            if (targetRefLen !== numUnitsY || targetGenLen !== numUnitsX) {
                 // Reset to optimal layout for the new dimensions
                animateGridChange(targetGenLen, targetRefLen, i => {
                    // Need to calculate the target floor path to find the optimal Y
                    const tempWindows = get_mapping_windows_js(targetRefLen, targetGenLen);
                    const { floor_path } = computeIdealNarrativeLineBandJS(tempWindows.precision_windows, targetGenLen, targetRefLen);
                    return (floor_path.find(p => p.x === i) || { y: Math.floor(targetRefLen / 2) }).y;
                });
            }
        }

        document.getElementById('start-tour-btn').addEventListener('click', () => tourManager.start());
        elements.refLenInput.addEventListener('change', handleGridInputChange);
        elements.genLenInput.addEventListener('change', handleGridInputChange);
        elements.lctSlider.addEventListener('input', () => {
            currentLct = parseInt(elements.lctSlider.value, 10); 
            elements.lctValueDisplay.textContent = currentLct;
            updateLctDescription();
            renderGenChunkMarkers(); 
        });

        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer); 
            resizeTimer = setTimeout(() => { renderAll(); }, 150); 
        });

        window.addEventListener('load', () => {
            lctExplorerManager.init();
            initializeStateAndRender();
        });
    </script>

    <!-- Add CSS animation for smooth line drawing -->
    <style>
        @keyframes drawLine {
            to {
                stroke-dashoffset: 0;
            }
        }
    </style>
</body>
</html>
